<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AugmentWebviewStateStore">
    <option name="stateMap">
      <map>
        <entry key="CHAT_STATE" value="{&quot;currentConversationId&quot;:&quot;2d41db03-0c61-4285-9125-d3af22174d1f&quot;,&quot;conversations&quot;:{&quot;2d41db03-0c61-4285-9125-d3af22174d1f&quot;:{&quot;id&quot;:&quot;2d41db03-0c61-4285-9125-d3af22174d1f&quot;,&quot;createdAtIso&quot;:&quot;2025-08-30T11:32:59.069Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-08-30T11:33:36.914Z&quot;,&quot;chatHistory&quot;:[{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;b864ae81-f6ce-4c63-bc9a-b0bfd5b653c2&quot;,&quot;request_message&quot;:&quot;explain this project&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;explain this project&quot;}]}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_019E2SQJ2h4R7ERdif5Bchvz&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;.\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;I'll help you understand this project by exploring the codebase structure and examining the key files.\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;explain this project&quot;}},{&quot;id&quot;:1,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:09.727Z&quot;,&quot;response_text&quot;:&quot;I'll help you understand this project by exploring the codebase structure and examining the key files.\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;287b4cdc-df98-45bb-a3b0-32a14b3e666b&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_018eA5Th46jQhxhc2Q5nMVoW&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;pom.xml\&quot;, \&quot;type\&quot;: \&quot;file\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;Let me examine the project structure and key files to understand what this project is about.\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in ., excluding hidden items:\n./pom.xml\n./src\n./src\\main\n./src\\test\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_019E2SQJ2h4R7ERdif5Bchvz&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:12.967Z&quot;,&quot;response_text&quot;:&quot;Let me examine the project structure and key files to understand what this project is about.\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;0bbbf26b-7b72-487f-8e50-5ab4e3eeca97&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_01SFVmH4BRzjnpNXKgDVW9kd&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/main/java\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on pom.xml:\n     1\t&lt;project xmlns=\&quot;http://maven.apache.org/POM/4.0.0\&quot;\n     2\t         xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;\n     3\t         xsi:schemaLocation=\&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\&quot;&gt;\n     4\t    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n     5\t\n     6\t    &lt;groupId&gt;com.example&lt;/groupId&gt;\n     7\t    &lt;artifactId&gt;tinyrest&lt;/artifactId&gt;\n     8\t    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n     9\t    &lt;packaging&gt;jar&lt;/packaging&gt;\n    10\t\n    11\t    &lt;properties&gt;\n    12\t        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n    13\t        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n    14\t        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    15\t        &lt;junit.version&gt;5.10.2&lt;/junit.version&gt;\n    16\t        &lt;jackson.version&gt;2.17.2&lt;/jackson.version&gt;\n    17\t    &lt;/properties&gt;\n    18\t\n    19\t    &lt;dependencies&gt;\n    20\t        &lt;!-- Jackson core --&gt;\n    21\t        &lt;dependency&gt;\n    22\t            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    23\t            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    24\t            &lt;version&gt;${jackson.version}&lt;/version&gt;\n    25\t        &lt;/dependency&gt;\n    26\t\n    27\t        &lt;!-- Jackson YAML --&gt;\n    28\t        &lt;dependency&gt;\n    29\t            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;\n    30\t            &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;\n    31\t            &lt;version&gt;${jackson.version}&lt;/version&gt;\n    32\t        &lt;/dependency&gt;\n    33\t\n    34\t        &lt;!-- JUnit 5 API --&gt;\n    35\t        &lt;dependency&gt;\n    36\t            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    37\t            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n    38\t            &lt;version&gt;${junit.version}&lt;/version&gt;\n    39\t            &lt;scope&gt;test&lt;/scope&gt;\n    40\t        &lt;/dependency&gt;\n    41\t\n    42\t        &lt;!-- JUnit 5 Engine (runtime for tests) --&gt;\n    43\t        &lt;dependency&gt;\n    44\t            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    45\t            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;\n    46\t            &lt;version&gt;${junit.version}&lt;/version&gt;\n    47\t            &lt;scope&gt;test&lt;/scope&gt;\n    48\t        &lt;/dependency&gt;\n    49\t    &lt;/dependencies&gt;\n    50\t\n    51\t    &lt;build&gt;\n    52\t        &lt;plugins&gt;\n    53\t            &lt;!-- Run JUnit 5 tests --&gt;\n    54\t            &lt;plugin&gt;\n    55\t                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    56\t                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    57\t                &lt;version&gt;3.2.5&lt;/version&gt;\n    58\t                &lt;configuration&gt;\n    59\t                    &lt;useModulePath&gt;false&lt;/useModulePath&gt;\n    60\t                &lt;/configuration&gt;\n    61\t            &lt;/plugin&gt;\n    62\t        &lt;/plugins&gt;\n    63\t    &lt;/build&gt;\n    64\t&lt;/project&gt;\n    65\t\nTotal lines in file: 65\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_018eA5Th46jQhxhc2Q5nMVoW&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:16.871Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;5d780c1c-c865-4901-a6e7-4d18d0d638f1&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_01DonkEK7eJqBkmPJqd1xDMf&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/main/java/dev/mars\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in src/main/java, excluding hidden items:\nsrc/main/java/dev\nsrc/main/java/dev\\mars\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_01SFVmH4BRzjnpNXKgDVW9kd&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:19.828Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;84333b92-d7e4-4ddf-ae08-edcc6acdaeb9&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_01KeqNJqjS7Qzi3povf7JzjY&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/main/java/dev/mars/tinyrest/tinyrest.java\&quot;, \&quot;type\&quot;: \&quot;file\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in src/main/java/dev/mars, excluding hidden items:\nsrc/main/java/dev/mars/tinyrest\nsrc/main/java/dev/mars/tinyrest\\tinyrest.java\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_01DonkEK7eJqBkmPJqd1xDMf&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:22.959Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;5e18c232-3846-4c48-b02c-b73ea56b53b2&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_016zW7VL1HcuKyBLmzzn1gQK&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/test\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/main/java/dev/mars/tinyrest/tinyrest.java:\n     1\t\n     2\t// TinyRest.java\n     3\t//\n     4\t// Build deps (Maven):\n     5\t//   - com.fasterxml.jackson.core:jackson-databind:2.17.2\n     6\t//   - com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.17.2\n     7\t// Test deps (for the JUnit extension):\n     8\t//   - org.junit.jupiter:junit-jupiter:5.x\n     9\t//\n    10\t// Run:\n    11\t//   mvn -q -DskipTests package\n    12\t//   java -cp target/your-jar-with-deps.jar:. TinyRest src/test/resources/tinyrest.yml\n    13\t//\n    14\t// Example tinyrest.yml shown at bottom of this file’s comment header.\n    15\t\n    16\timport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n    17\timport com.fasterxml.jackson.core.JsonGenerator;\n    18\timport com.fasterxml.jackson.core.type.TypeReference;\n    19\timport com.fasterxml.jackson.databind.DeserializationFeature;\n    20\timport com.fasterxml.jackson.databind.ObjectMapper;\n    21\timport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n    22\timport com.sun.net.httpserver.Headers;\n    23\timport com.sun.net.httpserver.HttpExchange;\n    24\timport com.sun.net.httpserver.HttpServer;\n    25\t\n    26\timport java.io.*;\n    27\timport java.net.InetSocketAddress;\n    28\timport java.net.URI;\n    29\timport java.nio.charset.StandardCharsets;\n    30\timport java.nio.file.*;\n    31\timport java.time.Instant;\n    32\timport java.time.format.DateTimeFormatter;\n    33\timport java.util.*;\n    34\timport java.util.concurrent.*;\n    35\timport java.util.regex.Matcher;\n    36\timport java.util.regex.Pattern;\n    37\timport java.util.stream.Collectors;\n    38\t\n    39\tpublic class TinyRest {\n    40\t\n    41\t    public static void main(String[] args) throws Exception {\n    42\t        if (args.length == 0) {\n    43\t            System.err.println(\&quot;Usage: java TinyRest &lt;tinyrest.yml|json&gt;\&quot;);\n    44\t            System.exit(1);\n    45\t        }\n    46\t        var path = Paths.get(args[0]).toAbsolutePath();\n    47\t        var cfg = loadConfig(path.toString());\n    48\t        var handle = start(cfg, path);\n    49\t        System.out.printf(\&quot;TinyRest ready on http://localhost:%d/  (watching %s)%n\&quot;,\n    50\t                handle.boundAddress().getPort(), path);\n    51\t    }\n    52\t\n    53\t    // ---------- Public API ----------\n    54\t    public static MockConfig loadConfig(String path) throws IOException {\n    55\t        try (var in = new FileInputStream(path)) {\n    56\t            boolean yaml = path.endsWith(\&quot;.yml\&quot;) || path.endsWith(\&quot;.yaml\&quot;);\n    57\t            ObjectMapper mapper = yaml ? yamlMapper() : jsonMapper();\n    58\t            return mapper.readValue(in, MockConfig.class);\n    59\t        }\n    60\t    }\n    61\t\n    62\t    public static ServerHandle start(MockConfig cfg, Path configPath) throws IOException {\n    63\t        int port = cfg.port != null ? cfg.port : 8080;\n    64\t        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n    65\t        server.setExecutor(Executors.newFixedThreadPool(Math.max(4, Runtime.getRuntime().availableProcessors())));\n    66\t        var engine = new Engine(defaults(cfg), configPath);\n    67\t        server.createContext(\&quot;/\&quot;, ex -&gt; { try { engine.handle(ex); } finally { ex.close(); }});\n    68\t        server.start();\n    69\t        if (engine.features.hotReload) engine.startFileWatcher();\n    70\t        return new ServerHandle(server, engine);\n    71\t    }\n    72\t\n    73\t    // ---------- Engine ----------\n    74\t    static class Engine {\n    75\t        volatile MockConfig cfg;\n    76\t        final ObjectMapper om = jsonMapper();\n    77\t        final Map&lt;String, ResourceStore&gt; stores = new ConcurrentHashMap&lt;&gt;();\n    78\t        volatile List&lt;Route&gt; routes = new CopyOnWriteArrayList&lt;&gt;();\n    79\t        final Path configPath;\n    80\t        final Features features;\n    81\t        final Recorder recorder;\n    82\t\n    83\t        Engine(MockConfig cfg, Path configPath) {\n    84\t            this.cfg = cfg;\n    85\t            this.configPath = configPath;\n    86\t            this.features = Features.from(cfg.features);\n    87\t            if (\&quot;strict\&quot;.equalsIgnoreCase(features.schemaValidation)) validateOrDie(cfg);\n    88\t            else validateLenient(cfg);\n    89\t\n    90\t            initStores();\n    91\t            initRoutes();\n    92\t            this.recorder = new Recorder(features.recordReplay, om);\n    93\t            if (recorder.isReplay()) recorder.loadFromFile();\n    94\t        }\n    95\t\n    96\t        void handle(HttpExchange ex) throws IOException {\n    97\t            addCORS(ex);\n    98\t            if (handleCorsPreflight(ex)) return;\n    99\t            withLatency(cfg.artificialLatencyMs);\n   100\t            maybeChaos(cfg.chaosFailRate);\n   101\t\n   102\t            try {\n   103\t                String method = ex.getRequestMethod();\n   104\t                String path = ex.getRequestURI().getPath();\n   105\t\n   106\t                // record/replay — replay happens BEFORE any routing\n   107\t                if (recorder.isReplay()) {\n   108\t                    var hit = recorder.tryReplay(ex);\n   109\t                    if (hit != null) { write(ex, hit); return; }\n   110\t                    if (\&quot;error\&quot;.equalsIgnoreCase(recorder.replayOnMiss())) {\n   111\t                        write(ex, Response.json(501, Map.of(\&quot;error\&quot;, \&quot;replay_miss\&quot;, \&quot;path\&quot;, path))); return;\n   112\t                    }\n   113\t                    // else: fallback to normal routing\n   114\t                }\n   115\t\n   116\t                for (Route r : routes) {\n   117\t                    Matcher m = r.pattern.matcher(path);\n   118\t                    if (r.method.equals(method) &amp;&amp; m.matches()) {\n   119\t                        var ctx = new Ctx(ex, om, cfg, m, r, features);\n   120\t                        if (r.mutates &amp;&amp; !isAuthorized(ctx)) throw new Unauthorized(\&quot;Missing/invalid bearer token\&quot;);\n   121\t                        Response resp = r.handler.handle(ctx);\n   122\t                        write(ex, resp);\n   123\t                        // record AFTER successful handling\n   124\t                        if (recorder.isRecording()) recorder.record(ex, resp);\n   125\t                        return;\n   126\t                    }\n   127\t                }\n   128\t                var notFound = Response.json(404, Map.of(\n   129\t                        \&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No route \&quot;+method+\&quot; \&quot;+path));\n   130\t                write(ex, notFound);\n   131\t                if (recorder.isRecording()) recorder.record(ex, notFound);\n   132\t            } catch (BadRequest e) {\n   133\t                var resp = Response.json(400, Map.of(\&quot;error\&quot;,\&quot;bad_request\&quot;,\&quot;message\&quot;, e.getMessage()));\n   134\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   135\t            } catch (Unauthorized e) {\n   136\t                var resp = Response.json(401, Map.of(\&quot;error\&quot;,\&quot;unauthorized\&quot;,\&quot;message\&quot;, e.getMessage()));\n   137\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   138\t            } catch (Exception e) {\n   139\t                e.printStackTrace();\n   140\t                var resp = Response.json(500, Map.of(\&quot;error\&quot;,\&quot;internal\&quot;,\&quot;message\&quot;,\&quot;boom\&quot;));\n   141\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   142\t            }\n   143\t        }\n   144\t\n   145\t        private void initStores() {\n   146\t            stores.clear();\n   147\t            if (cfg.resources == null) return;\n   148\t            for (var r : cfg.resources) {\n   149\t                String idField = blank(r.idField) ? \&quot;id\&quot; : r.idField;\n   150\t                var store = new ResourceStore(r.name, idField);\n   151\t                if (r.seed != null) {\n   152\t                    for (Map&lt;String,Object&gt; row : r.seed) {\n   153\t                        Object id = row.get(idField);\n   154\t                        if (id == null) { id = UUID.randomUUID().toString(); row.put(idField, id); }\n   155\t                        store.put(id.toString(), deepCopy(row));\n   156\t                    }\n   157\t                }\n   158\t                stores.put(r.name, store);\n   159\t            }\n   160\t        }\n   161\t\n   162\t        private void initRoutes() {\n   163\t            var newRoutes = new ArrayList&lt;Route&gt;();\n   164\t\n   165\t            if (cfg.resources != null) {\n   166\t                for (var r : cfg.resources) {\n   167\t                    boolean enable = r.enableCrud == null || r.enableCrud;\n   168\t                    if (!enable) continue;\n   169\t                    var base = \&quot;/api/\&quot; + r.name;\n   170\t\n   171\t                    newRoutes.add(new Route(\&quot;GET\&quot;, base, false, (ctx) -&gt; {\n   172\t                        var store = stores.get(r.name);\n   173\t                        var qp = ctx.query();\n   174\t                        int limit = qp.getInt(\&quot;limit\&quot;, 50);\n   175\t                        int offset = qp.getInt(\&quot;offset\&quot;, 0);\n   176\t                        return Response.json(200, store.list(limit, offset));\n   177\t                    }));\n   178\t\n   179\t                    newRoutes.add(new Route(\&quot;POST\&quot;, base, true, (ctx) -&gt; {\n   180\t                        var store = stores.get(r.name);\n   181\t                        Map&lt;String,Object&gt; in = ctx.readJsonMap();\n   182\t                        Object id = in.get(store.idField);\n   183\t                        if (id == null) { id = UUID.randomUUID().toString(); in.put(store.idField, id); }\n   184\t                        store.put(id.toString(), in);\n   185\t                        return Response.json(201, in).withHeader(\&quot;Location\&quot;, base + \&quot;/\&quot; + id);\n   186\t                    }));\n   187\t\n   188\t                    newRoutes.add(new Route(\&quot;GET\&quot;, base + \&quot;/{id}\&quot;, false, (ctx) -&gt; {\n   189\t                        var store = stores.get(r.name);\n   190\t                        var row = store.get(ctx.path(\&quot;id\&quot;));\n   191\t                        return row == null ? Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;))\n   192\t                                : Response.json(200, row);\n   193\t                    }));\n   194\t\n   195\t                    newRoutes.add(new Route(\&quot;PUT\&quot;, base + \&quot;/{id}\&quot;, true, (ctx) -&gt; {\n   196\t                        var store = stores.get(r.name);\n   197\t                        String id = ctx.path(\&quot;id\&quot;);\n   198\t                        var existing = store.get(id);\n   199\t                        if (existing == null) return Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;));\n   200\t                        var patch = ctx.readJsonMap();\n   201\t                        existing.putAll(patch);\n   202\t                        existing.put(store.idField, id);\n   203\t                        store.put(id, existing);\n   204\t                        return Response.json(200, existing);\n   205\t                    }));\n   206\t\n   207\t                    newRoutes.add(new Route(\&quot;DELETE\&quot;, base + \&quot;/{id}\&quot;, true, (ctx) -&gt; {\n   208\t                        var store = stores.get(r.name);\n   209\t                        boolean removed = store.remove(ctx.path(\&quot;id\&quot;));\n   210\t                        return removed ? new Response(204, new LinkedHashMap&lt;&gt;(), null)\n   211\t                                : Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;));\n   212\t                    }));\n   213\t                }\n   214\t            }\n   215\t\n   216\t            if (cfg.staticEndpoints != null) {\n   217\t                for (var se : cfg.staticEndpoints) {\n   218\t                    String method = blank(se.method) ? \&quot;GET\&quot; : se.method;\n   219\t                    int status = se.status == null ? 200 : se.status;\n   220\t                    boolean mutates = switch (method) {\n   221\t                        case \&quot;POST\&quot;,\&quot;PUT\&quot;,\&quot;DELETE\&quot;,\&quot;PATCH\&quot; -&gt; true; default -&gt; false;\n   222\t                    };\n   223\t                    newRoutes.add(new Route(method, se.path, mutates, (ctx) -&gt; {\n   224\t                        if (Boolean.TRUE.equals(se.echoRequest)) {\n   225\t                            return Response.json(status, Map.of(\n   226\t                                    \&quot;method\&quot;, ctx.exchange.getRequestMethod(),\n   227\t                                    \&quot;path\&quot;, ctx.exchange.getRequestURI().getPath(),\n   228\t                                    \&quot;query\&quot;, ctx.query().raw,\n   229\t                                    \&quot;headers\&quot;, ctx.headersMap(),\n   230\t                                    \&quot;body\&quot;, ctx.readBodyAsString(),\n   231\t                                    \&quot;time\&quot;, Instant.now().toString()\n   232\t                            ));\n   233\t                        } else {\n   234\t                            Object body = se.response == null ? Map.of() : deepCopy(se.response);\n   235\t                            if (features.templating) body = Template.apply(body, ctx);\n   236\t                            return Response.json(status, body);\n   237\t                        }\n   238\t                    }));\n   239\t                }\n   240\t            }\n   241\t            this.routes = newRoutes;\n   242\t        }\n   243\t\n   244\t        // ---- Hot reload ----\n   245\t        void startFileWatcher() {\n   246\t            Thread t = new Thread(() -&gt; {\n   247\t                try (WatchService ws = FileSystems.getDefault().newWatchService()) {\n   248\t                    var dir = configPath.getParent();\n   249\t                    if (dir == null) return;\n   250\t                    dir.register(ws, StandardWatchEventKinds.ENTRY_MODIFY);\n   251\t                    while (true) {\n   252\t                        var key = ws.take();\n   253\t                        for (WatchEvent&lt;?&gt; ev : key.pollEvents()) {\n   254\t                            var changed = (Path) ev.context();\n   255\t                            if (changed != null &amp;&amp; configPath.getFileName().equals(changed)) {\n   256\t                                try {\n   257\t                                    var newCfg = loadConfig(configPath.toString());\n   258\t                                    // validate &amp; swap\n   259\t                                    if (\&quot;strict\&quot;.equalsIgnoreCase(features.schemaValidation)) validateOrDie(newCfg);\n   260\t                                    else validateLenient(newCfg);\n   261\t                                    this.cfg = defaults(newCfg);\n   262\t                                    initStores();\n   263\t                                    initRoutes();\n   264\t                                    System.out.println(\&quot;[hot-reload] applied config at \&quot; + Instant.now());\n   265\t                                } catch (Exception e) {\n   266\t                                    System.err.println(\&quot;[hot-reload] failed: \&quot; + e.getMessage());\n   267\t                                }\n   268\t                            }\n   269\t                        }\n   270\t                        key.reset();\n   271\t                    }\n   272\t                } catch (Exception e) {\n   273\t                    System.err.println(\&quot;[hot-reload] watcher stopped: \&quot; + e.getMessage());\n   274\t                }\n   275\t            }, \&quot;tinyrest-hot-reload\&quot;);\n   276\t            t.setDaemon(true);\n   277\t            t.start();\n   278\t        }\n   279\t    }\n   280\t\n   281\t    // ---------- Template engine ----------\n   282\t    static class Template {\n   283\t        private static final Pattern P = Pattern.compile(\&quot;\\\\{\\\\{\\\\s*([^}]+)\\\\s*}}\&quot;);\n   284\t\n   285\t        static Object apply(Object node, Ctx ctx) {\n   286\t            if (node instanceof Map&lt;?,?&gt; m) {\n   287\t                Map&lt;String,Object&gt; out = new LinkedHashMap&lt;&gt;();\n   288\t                for (var e : m.entrySet()) out.put(String.valueOf(e.getKey()), apply(e.getValue(), ctx));\n   289\t                return out;\n   290\t            } else if (node instanceof List&lt;?&gt; list) {\n   291\t                List&lt;Object&gt; out = new ArrayList&lt;&gt;();\n   292\t                for (var v : list) out.add(apply(v, ctx));\n   293\t                return out;\n   294\t            } else if (node instanceof String s) {\n   295\t                return renderString(s, ctx);\n   296\t            } else {\n   297\t                return node;\n   298\t            }\n   299\t        }\n   300\t\n   301\t        static String renderString(String s, Ctx ctx) {\n   302\t            Matcher m = P.matcher(s);\n   303\t            StringBuffer sb = new StringBuffer();\n   304\t            while (m.find()) {\n   305\t                String expr = m.group(1).trim();\n   306\t                String val = eval(expr, ctx);\n   307\t                m.appendReplacement(sb, Matcher.quoteReplacement(val));\n   308\t            }\n   309\t            m.appendTail(sb);\n   310\t            return sb.toString();\n   311\t        }\n   312\t\n   313\t        static String eval(String expr, Ctx ctx) {\n   314\t            // builtins\n   315\t            if (\&quot;now\&quot;.equals(expr)) return DateTimeFormatter.ISO_INSTANT.format(Instant.now());\n   316\t            if (\&quot;uuid\&quot;.equals(expr)) return UUID.randomUUID().toString();\n   317\t            if (expr.startsWith(\&quot;path.\&quot;)) return nvl(ctx.pathOrNull(expr.substring(5)));\n   318\t            if (expr.startsWith(\&quot;query.\&quot;)) return nvl(ctx.query().get(expr.substring(6), \&quot;\&quot;));\n   319\t            if (expr.startsWith(\&quot;body.\&quot;))  return nvl(jsonPointer(ctx.bodyAsMap(), expr.substring(5)));\n   320\t            if (expr.startsWith(\&quot;header.\&quot;)) return nvl(ctx.header(expr.substring(7)));\n   321\t            // random.int(a,b)\n   322\t            if (expr.startsWith(\&quot;random.int(\&quot;) &amp;&amp; expr.endsWith(\&quot;)\&quot;)) {\n   323\t                try {\n   324\t                    String inner = expr.substring(\&quot;random.int(\&quot;.length(), expr.length()-1);\n   325\t                    String[] parts = inner.split(\&quot;,\&quot;, 2);\n   326\t                    int a = Integer.parseInt(parts[0].trim());\n   327\t                    int b = Integer.parseInt(parts[1].trim());\n   328\t                    int n = ThreadLocalRandom.current().nextInt(a, b+1);\n   329\t                    return String.valueOf(n);\n   330\t                } catch (Exception e) { return \&quot;\&quot;; }\n   331\t            }\n   332\t            return \&quot;\&quot;; // unknown expression -&gt; empty\n   333\t        }\n   334\t\n   335\t        @SuppressWarnings(\&quot;unchecked\&quot;)\n   336\t        static String jsonPointer(Map&lt;String,Object&gt; m, String dotted) {\n   337\t            if (m == null) return \&quot;\&quot;;\n   338\t            Object cur = m;\n   339\t            for (String seg : dotted.split(\&quot;\\\\.\&quot;)) {\n   340\t                if (!(cur instanceof Map&lt;?,?&gt; map)) return \&quot;\&quot;;\n   341\t                cur = ((Map&lt;String,Object&gt;) map).get(seg);\n   342\t                if (cur == null) return \&quot;\&quot;;\n   343\t            }\n   344\t            return String.valueOf(cur);\n   345\t        }\n   346\t        static String nvl(String s) { return s == null ? \&quot;\&quot; : s; }\n   347\t    }\n   348\t\n   349\t    // ---------- Recorder / Replayer ----------\n   350\t    static class Recorder {\n   351\t        final RecordReplay rr;\n   352\t        final ObjectMapper om;\n   353\t        Recorder(RecordReplay rr, ObjectMapper om) { this.rr = rr == null ? new RecordReplay() : rr; this.om = om; }\n   354\t        boolean isRecording() { return rr != null &amp;&amp; \&quot;record\&quot;.equalsIgnoreCase(rr.mode); }\n   355\t        boolean isReplay()    { return rr != null &amp;&amp; \&quot;replay\&quot;.equalsIgnoreCase(rr.mode); }\n   356\t        String replayOnMiss() { return rr == null ? \&quot;fallback\&quot; : (blank(rr.replayOnMiss) ? \&quot;fallback\&quot; : rr.replayOnMiss); }\n   357\t\n   358\t        final List&lt;ReplayItem&gt; items = new CopyOnWriteArrayList&lt;&gt;();\n   359\t\n   360\t        void loadFromFile() {\n   361\t            if (blank(rr.file)) return;\n   362\t            var f = Paths.get(rr.file);\n   363\t            if (!Files.exists(f)) return;\n   364\t            try (var br = Files.newBufferedReader(f, StandardCharsets.UTF_8)) {\n   365\t                String line;\n   366\t                while ((line = br.readLine()) != null) {\n   367\t                    items.add(om.readValue(line, ReplayItem.class));\n   368\t                }\n   369\t                System.out.println(\&quot;[replay] loaded \&quot; + items.size() + \&quot; entries from \&quot; + rr.file);\n   370\t            } catch (Exception e) {\n   371\t                System.err.println(\&quot;[replay] failed loading \&quot; + rr.file + \&quot;: \&quot; + e.getMessage());\n   372\t            }\n   373\t        }\n   374\t\n   375\t        void record(HttpExchange ex, Response resp) {\n   376\t            if (!isRecording() || blank(rr.file)) return;\n   377\t            try {\n   378\t                var item = ReplayItem.from(ex, resp, rr);\n   379\t                try (var fw = new FileWriter(rr.file, true);\n   380\t                     var bw = new BufferedWriter(fw)) {\n   381\t                    om.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n   382\t                    bw.write(om.writeValueAsString(item));\n   383\t                    bw.write(\&quot;\\n\&quot;);\n   384\t                }\n   385\t            } catch (Exception e) {\n   386\t                System.err.println(\&quot;[record] failed: \&quot; + e.getMessage());\n   387\t            }\n   388\t        }\n   389\t\n   390\t        Response tryReplay(HttpExchange ex) {\n   391\t            if (!isReplay()) return null;\n   392\t            var req = ReplayItem.captureRequest(ex);\n   393\t            for (var it : items) {\n   394\t                if (it.matches(req, rr)) return it.toResponse();\n   395\t            }\n   396\t            return null;\n   397\t        }\n   398\t    }\n   399\t\n   400\t    // ---------- HTTP plumbing ----------\n   401\t    interface Handler { Response handle(Ctx ctx) throws Exception; }\n   402\t    static class Route {\n   403\t        final String method; final Pattern pattern; final Handler handler; final boolean mutates;\n   404\t        Route(String method, String pathTemplate, boolean mutates, Handler handler) {\n   405\t            this.method = method; this.pattern = compile(pathTemplate); this.mutates = mutates; this.handler = handler;\n   406\t        }\n   407\t        private static Pattern compile(String tpl) {\n   408\t            String regex = Arrays.stream(tpl.split(\&quot;/\&quot;))\n   409\t                    .filter(s -&gt; !s.isEmpty())\n   410\t                    .map(seg -&gt; seg.startsWith(\&quot;{\&quot;) &amp;&amp; seg.endsWith(\&quot;}\&quot;)\n   411\t                            ? \&quot;(?&lt;\&quot; + seg.substring(1, seg.length()-1) + \&quot;&gt;[^/]+)\&quot;\n   412\t                            : Pattern.quote(seg))\n   413\t                    .collect(Collectors.joining(\&quot;/\&quot;, \&quot;^/\&quot;, \&quot;$\&quot;));\n   414\t            return Pattern.compile(regex);\n   415\t        }\n   416\t    }\n   417\t\n   418\t    static class Ctx {\n   419\t        final HttpExchange exchange; final ObjectMapper om; final MockConfig cfg; final Matcher matcher; final Route route; final Features features;\n   420\t        Map&lt;String,Object&gt; bodyCache;\n   421\t\n   422\t        Ctx(HttpExchange exchange, ObjectMapper om, MockConfig cfg, Matcher matcher, Route route, Features features) {\n   423\t            this.exchange = exchange; this.om = om; this.cfg = cfg; this.matcher = matcher; this.route = route; this.features = features;\n   424\t        }\n   425\t        String path(String group) { return matcher.group(group); }\n   426\t        String pathOrNull(String group) { try { return matcher.group(group); } catch (Exception e) { return null; } }\n   427\t        Query query() { return new Query(exchange.getRequestURI()); }\n   428\t        String header(String name) { var v = exchange.getRequestHeaders().get(name); return (v==null||v.isEmpty())?null:v.get(0); }\n   429\t        Map&lt;String, List&lt;String&gt;&gt; headersMap() {\n   430\t            return exchange.getRequestHeaders().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n   431\t        }\n   432\t        Map&lt;String,Object&gt; readJsonMap() {\n   433\t            if (!\&quot;application/json\&quot;.equalsIgnoreCase(contentType())) throw new BadRequest(\&quot;Content-Type must be application/json\&quot;);\n   434\t            try (var is = exchange.getRequestBody()) { return om.readValue(is, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){}); }\n   435\t            catch (IOException e) { throw new BadRequest(\&quot;Invalid JSON\&quot;); }\n   436\t        }\n   437\t        Map&lt;String,Object&gt; bodyAsMap() {\n   438\t            if (bodyCache != null) return bodyCache;\n   439\t            try (var is = exchange.getRequestBody()) {\n   440\t                byte[] bytes = is.readAllBytes();\n   441\t                if (bytes.length == 0) return bodyCache = Map.of();\n   442\t                return bodyCache = om.readValue(bytes, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){});\n   443\t            } catch (Exception e) { return bodyCache = Map.of(); }\n   444\t        }\n   445\t        String readBodyAsString() {\n   446\t            try (var is = exchange.getRequestBody()) { return new String(is.readAllBytes(), StandardCharsets.UTF_8); }\n   447\t            catch (IOException e) { return \&quot;\&quot;; }\n   448\t        }\n   449\t        String contentType() { var ct = header(\&quot;Content-Type\&quot;); return ct==null? \&quot;\&quot; : ct.split(\&quot;;\&quot;)[0].trim(); }\n   450\t    }\n   451\t\n   452\t    static class Query {\n   453\t        final Map&lt;String, List&lt;String&gt;&gt; raw;\n   454\t        Query(URI uri) { this.raw = split(uri.getRawQuery()); }\n   455\t        private static Map&lt;String, List&lt;String&gt;&gt; split(String q) {\n   456\t            Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();\n   457\t            if (q == null || q.isEmpty()) return map;\n   458\t            for (String kv : q.split(\&quot;&amp;\&quot;)) {\n   459\t                String[] parts = kv.split(\&quot;=\&quot;, 2);\n   460\t                String k = decode(parts[0]);\n   461\t                String v = parts.length &gt; 1 ? decode(parts[1]) : \&quot;\&quot;;\n   462\t                map.computeIfAbsent(k, __ -&gt; new ArrayList&lt;&gt;()).add(v);\n   463\t            }\n   464\t            return map;\n   465\t        }\n   466\t        private static String decode(String s) { return java.net.URLDecoder.decode(s, StandardCharsets.UTF_8); }\n   467\t        int getInt(String key, int def) { try { return Integer.parseInt(get(key, String.valueOf(def))); } catch (Exception e) { return def; } }\n   468\t        String get(String key, String def) { var list = raw.get(key); return (list==null||list.isEmpty())?def:list.get(0); }\n   469\t    }\n   470\t\n   471\t    static class Response {\n   472\t        final int status; final Map&lt;String,String&gt; headers; final byte[] body;\n   473\t        Response(int status, Map&lt;String,String&gt; headers, byte[] body) { this.status=status; this.headers=headers; this.body=body; }\n   474\t        static Response json(int status, Object obj) {\n   475\t            try {\n   476\t                var bytes = jsonMapper().writeValueAsBytes(obj);\n   477\t                var h = new LinkedHashMap&lt;String,String&gt;();\n   478\t                h.put(\&quot;Content-Type\&quot;, \&quot;application/json; charset=utf-8\&quot;);\n   479\t                return new Response(status, h, bytes);\n   480\t            } catch (Exception e) { throw new RuntimeException(e); }\n   481\t        }\n   482\t        Response withHeader(String k, String v){ headers.put(k, v); return this; }\n   483\t    }\n   484\t\n   485\t    static void write(HttpExchange ex, Response resp) throws IOException {\n   486\t        Headers h = ex.getResponseHeaders();\n   487\t        resp.headers.forEach(h::set);\n   488\t        long len = (resp.body == null || resp.status == 204) ? -1 : resp.body.length;\n   489\t        ex.sendResponseHeaders(resp.status, len);\n   490\t        if (resp.body != null &amp;&amp; resp.status != 204) try (var os = ex.getResponseBody()) { os.write(resp.body); }\n   491\t    }\n   492\t\n   493\t    static void addCORS(HttpExchange ex) {\n   494\t        Headers h = ex.getResponseHeaders();\n   495\t        h.add(\&quot;Access-Control-Allow-Origin\&quot;, \&quot;*\&quot;);\n   496\t        h.add(\&quot;Access-Control-Allow-Methods\&quot;, \&quot;GET,POST,PUT,DELETE,OPTIONS\&quot;);\n   497\t        h.add(\&quot;Access-Control-Allow-Headers\&quot;, \&quot;Content-Type, Authorization\&quot;);\n   498\t    }\n   499\t    static boolean handleCorsPreflight(HttpExchange ex) throws IOException {\n   500\t        if (!\&quot;OPTIONS\&quot;.equals(ex.getRequestMethod())) return false;\n   501\t        ex.sendResponseHeaders(204, -1); return true;\n   502\t    }\n   503\t    static void withLatency(Long ms) { if (ms == null || ms &lt;= 0) return; try { Thread.sleep(ms); } catch (InterruptedException ignored) {} }\n   504\t    static void maybeChaos(Double rate) { if (rate == null || rate &lt;= 0) return; if (ThreadLocalRandom.current().nextDouble() &lt; rate) throw new RuntimeException(\&quot;chaos\&quot;); }\n   505\t    static boolean isAuthorized(Ctx ctx) {\n   506\t        if (blank(ctx.cfg.authToken)) return true;\n   507\t        var h = ctx.header(\&quot;Authorization\&quot;);\n   508\t        return h != null &amp;&amp; h.equals(\&quot;Bearer \&quot; + ctx.cfg.authToken);\n   509\t    }\n   510\t\n   511\t    static ObjectMapper jsonMapper() { return new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); }\n   512\t    static ObjectMapper yamlMapper() { return new ObjectMapper(new YAMLFactory()).configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); }\n   513\t    static Map&lt;String,Object&gt; deepCopy(Map&lt;String,Object&gt; m) { return jsonMapper().convertValue(m, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){}); }\n   514\t    static boolean blank(String s){ return s==null || s.isBlank(); }\n   515\t\n   516\t    // ---------- In-memory store ----------\n   517\t    static class ResourceStore {\n   518\t        final String name; final String idField; final ConcurrentMap&lt;String, Map&lt;String,Object&gt;&gt; data = new ConcurrentHashMap&lt;&gt;();\n   519\t        ResourceStore(String name, String idField) { this.name = name; this.idField = idField; }\n   520\t        void put(String id, Map&lt;String,Object&gt; row){ data.put(id, deepCopy(row)); }\n   521\t        Map&lt;String,Object&gt; get(String id){ return data.get(id); }\n   522\t        boolean remove(String id){ return data.remove(id) != null; }\n   523\t        List&lt;Map&lt;String,Object&gt;&gt; list(int limit, int offset) {\n   524\t            return data.values().stream()\n   525\t                    .sorted(Comparator.comparing(o -&gt; String.valueOf(o.getOrDefault(idField, \&quot;\&quot;))))\n   526\t                    .skip(Math.max(0, offset))\n   527\t                    .limit(Math.max(1, limit))\n   528\t                    .map(TinyRest::deepCopy)\n   529\t                    .collect(Collectors.toList());\n   530\t        }\n   531\t    }\n   532\t\n   533\t    // ---------- Config / Features ----------\n   534\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   535\t    public static class MockConfig {\n   536\t        public Integer port;\n   537\t        public String authToken;\n   538\t        public Long artificialLatencyMs;\n   539\t        public Double chaosFailRate;\n   540\t        public FeaturesConfig features;\n   541\t        public List&lt;Resource&gt; resources;\n   542\t        public List&lt;StaticEndpoint&gt; staticEndpoints;\n   543\t    }\n   544\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   545\t    public static class Resource {\n   546\t        public String name;\n   547\t        public String idField;\n   548\t        public Boolean enableCrud;\n   549\t        public List&lt;Map&lt;String,Object&gt;&gt; seed;\n   550\t    }\n   551\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   552\t    public static class StaticEndpoint {\n   553\t        public String method;\n   554\t        public String path;\n   555\t        public Integer status;\n   556\t        public Map&lt;String,Object&gt; response;\n   557\t        public Boolean echoRequest;\n   558\t    }\n   559\t\n   560\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   561\t    public static class FeaturesConfig {\n   562\t        public Boolean templating;\n   563\t        public Boolean hotReload;\n   564\t        public String schemaValidation; // strict|lenient\n   565\t        public RecordReplay recordReplay;\n   566\t    }\n   567\t\n   568\t    static class Features {\n   569\t        final boolean templating;\n   570\t        final boolean hotReload;\n   571\t        final String schemaValidation;\n   572\t        final RecordReplay recordReplay;\n   573\t        static Features from(FeaturesConfig c) {\n   574\t            if (c == null) c = new FeaturesConfig();\n   575\t            return new Features(\n   576\t                    Boolean.TRUE.equals(c.templating),\n   577\t                    Boolean.TRUE.equals(c.hotReload),\n   578\t                    blank(c.schemaValidation) ? \&quot;lenient\&quot; : c.schemaValidation,\n   579\t                    c.recordReplay == null ? new RecordReplay() : c.recordReplay);\n   580\t        }\n   581\t        Features(boolean t, boolean hr, String sv, RecordReplay rr){ this.templating=t; this.hotReload=hr; this.schemaValidation=sv; this.recordReplay=rr; }\n   582\t    }\n   583\t\n   584\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   585\t    public static class RecordReplay {\n   586\t        public String mode;           // off|record|replay\n   587\t        public String file;           // JSONL file\n   588\t        public Match match;\n   589\t        public String replayOnMiss;   // error|fallback\n   590\t    }\n   591\t\n   592\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   593\t    public static class Match {\n   594\t        public Boolean method;\n   595\t        public Boolean path;\n   596\t        public Boolean query;\n   597\t        public Boolean body;\n   598\t        public List&lt;String&gt; headers;\n   599\t    }\n   600\t\n   601\t    static class ReplayItem {\n   602\t        public Map&lt;String,Object&gt; request;\n   603\t        public Map&lt;String,Object&gt; response;\n   604\t\n   605\t        static ReplayItem from(HttpExchange ex, Response resp, RecordReplay rr) throws IOException {\n   606\t            var it = new ReplayItem();\n   607\t            it.request = captureRequest(ex).toMap();\n   608\t            it.response = Map.of(\n   609\t                    \&quot;status\&quot;, resp.status,\n   610\t                    \&quot;headers\&quot;, ex.getResponseHeaders(), // response headers as set on exchange\n   611\t                    \&quot;bodyBase64\&quot;, Base64.getEncoder().encodeToString(resp.body == null ? new byte[0] : resp.body)\n   612\t            );\n   613\t            return it;\n   614\t        }\n   615\t\n   616\t        static CapturedRequest captureRequest(HttpExchange ex) {\n   617\t            String body = \&quot;\&quot;;\n   618\t            try (var is = ex.getRequestBody()) { body = new String(is.readAllBytes(), StandardCharsets.UTF_8); }\n   619\t            catch (Exception ignored) {}\n   620\t            Map&lt;String, List&lt;String&gt;&gt; headers = new LinkedHashMap&lt;&gt;();\n   621\t            ex.getRequestHeaders().forEach(headers::put);\n   622\t            return new CapturedRequest(ex.getRequestMethod(), ex.getRequestURI().getPath(), ex.getRequestURI().getRawQuery(), headers, body);\n   623\t        }\n   624\t\n   625\t        boolean matches(CapturedRequest req, RecordReplay rr) {\n   626\t            Match m = rr.match == null ? new Match() : rr.match;\n   627\t            boolean ok = true;\n   628\t            if (Boolean.TRUE.equals(m.method)) ok &amp;= Objects.equals(val(request, \&quot;method\&quot;), req.method);\n   629\t            if (Boolean.TRUE.equals(m.path))   ok &amp;= Objects.equals(val(request, \&quot;path\&quot;), req.path);\n   630\t            if (Boolean.TRUE.equals(m.query))  ok &amp;= Objects.equals(val(request, \&quot;query\&quot;), req.query);\n   631\t            if (Boolean.TRUE.equals(m.body))   ok &amp;= Objects.equals(val(request, \&quot;body\&quot;), req.body);\n   632\t            if (m.headers != null &amp;&amp; !m.headers.isEmpty()) {\n   633\t                @SuppressWarnings(\&quot;unchecked\&quot;)\n   634\t                Map&lt;String,List&lt;String&gt;&gt; h1 = (Map&lt;String,List&lt;String&gt;&gt;) request.get(\&quot;headers\&quot;);\n   635\t                for (String name : m.headers) {\n   636\t                    String k = canonicalHeader(h1, name);\n   637\t                    String k2 = canonicalHeader(req.headers, name);\n   638\t                    ok &amp;= Objects.equals(h1.get(k), req.headers.get(k2));\n   639\t                }\n   640\t            }\n   641\t            return ok;\n   642\t        }\n   643\t        static String canonicalHeader(Map&lt;String,?&gt; map, String name) {\n   644\t            for (String k : map.keySet()) if (k.equalsIgnoreCase(name)) return k;\n   645\t            return name;\n   646\t        }\n   647\t        static Object val(Map&lt;String,Object&gt; m, String k){ return m.get(k); }\n   648\t\n   649\t        Response toResponse() {\n   650\t            int status = (int) response.get(\&quot;status\&quot;);\n   651\t            byte[] body = new byte[0];\n   652\t            String b64 = String.valueOf(response.get(\&quot;bodyBase64\&quot;));\n   653\t            if (!\&quot;null\&quot;.equals(b64)) body = Base64.getDecoder().decode(b64);\n   654\t            Map&lt;String,String&gt; headers = new LinkedHashMap&lt;&gt;();\n   655\t            headers.put(\&quot;Content-Type\&quot;, \&quot;application/json; charset=utf-8\&quot;);\n   656\t            return new Response(status, headers, body);\n   657\t        }\n   658\t\n   659\t        static class CapturedRequest {\n   660\t            final String method, path, query, body; final Map&lt;String,List&lt;String&gt;&gt; headers;\n   661\t            CapturedRequest(String method, String path, String query, Map&lt;String,List&lt;String&gt;&gt; headers, String body) {\n   662\t                this.method = method; this.path = path; this.query = query; this.headers = headers; this.body = body;\n   663\t            }\n   664\t            Map&lt;String,Object&gt; toMap() {\n   665\t                return Map.of(\&quot;method\&quot;, method, \&quot;path\&quot;, path, \&quot;query\&quot;, query, \&quot;headers\&quot;, headers, \&quot;body\&quot;, body);\n   666\t            }\n   667\t        }\n   668\t    }\n   669\t\n   670\t    // ---------- Validation ----------\n   671\t    static void validateOrDie(MockConfig c) {\n   672\t        var errors = new ArrayList&lt;String&gt;();\n   673\t        if (c.resources != null) {\n   674\t            var names = new HashSet&lt;String&gt;();\n   675\t            for (var r : c.resources) {\n   676\t                if (blank(r.name)) errors.add(\&quot;resource.name is required\&quot;);\n   677\t                if (!names.add(r.name)) errors.add(\&quot;duplicate resource.name: \&quot; + r.name);\n   678\t                if (blank(r.idField)) errors.add(\&quot;resource.idField is required for: \&quot; + r.name);\n   679\t            }\n   680\t        }\n   681\t        if (c.staticEndpoints != null) {\n   682\t            for (var s : c.staticEndpoints) {\n   683\t                if (blank(s.path)) errors.add(\&quot;staticEndpoint.path is required\&quot;);\n   684\t            }\n   685\t        }\n   686\t        if (!errors.isEmpty()) throw new IllegalArgumentException(\&quot;Invalid config: \&quot; + errors);\n   687\t    }\n   688\t    static void validateLenient(MockConfig c) {\n   689\t        try { validateOrDie(c); } catch (Exception e) { System.err.println(\&quot;[lenient] \&quot; + e.getMessage()); }\n   690\t    }\n   691\t\n   692\t    // ---------- Control handle ----------\n   693\t    public static class ServerHandle {\n   694\t        private final HttpServer server; private final Engine engine;\n   695\t        ServerHandle(HttpServer server, Engine engine){ this.server = server; this.engine = engine; }\n   696\t        public void stop(int delaySec){ server.stop(delaySec); }\n   697\t        public InetSocketAddress boundAddress(){ return (InetSocketAddress) server.getAddress(); }\n   698\t    }\n   699\t\n   700\t    // ---------- Errors ----------\n   701\t    static class BadRequest extends RuntimeException { BadRequest(String m){ super(m); } }\n   702\t    static class Unauthorized extends RuntimeException { Unauthorized(String m){ super(m); } }\n   703\t\n   704\t    private static MockConfig defaults(MockConfig in) {\n   705\t        MockConfig c = in == null ? new MockConfig() : in;\n   706\t        if (c.port == null) c.port = 8080;\n   707\t        if (c.artificialLatencyMs == null) c.artificialLatencyMs = 0L;\n   708\t        if (c.chaosFailRate == null) c.chaosFailRate = 0.0;\n   709\t        if (c.features == null) c.features = new FeaturesConfig();\n   710\t        return c;\n   711\t    }\n   712\t\n   713\t    // ===== JUnit 5 Integration (TinyRest) =====\n   714\t    // Place this file under src/main/java and add JUnit 5 as a test-scoped dependency.\n   715\t    // Tests can then: @ExtendWith(TinyRest.JUnitTinyRestExtension.class) and @UseTinyRest(...)\n   716\t    // Params can be injected with @TinyRestBaseUrl on String or URI.\n   717\t\n   718\t    // (Imports for JUnit are at top-level in your test compile; here we fully-qualify to avoid extra imports.)\n   719\t\n   720\t    public static class JUnitTinyRestExtension implements org.junit.jupiter.api.extension.BeforeAllCallback,\n   721\t            org.junit.jupiter.api.extension.AfterAllCallback,\n   722\t            org.junit.jupiter.api.extension.ParameterResolver {\n   723\t\n   724\t        private static final org.junit.jupiter.api.extension.ExtensionContext.Namespace NS =\n   725\t                org.junit.jupiter.api.extension.ExtensionContext.Namespace.create(\&quot;TinyRest\&quot;);\n   726\t        private static final String STORE_KEY = \&quot;serverHandle\&quot;;\n   727\t\n   728\t        @Override\n   729\t        public void beforeAll(org.junit.jupiter.api.extension.ExtensionContext context) throws Exception {\n   730\t            var store = context.getStore(NS);\n   731\t\n   732\t            UseTinyRest cfgAnn = findAnnotation(context, UseTinyRest.class);\n   733\t            if (cfgAnn == null) {\n   734\t                throw new IllegalStateException(\&quot;@UseTinyRest is required on the test class when using JUnitTinyRestExtension.\&quot;);\n   735\t            }\n   736\t\n   737\t            String configPath = cfgAnn.configPath().isBlank() ? \&quot;src/test/resources/tinyrest.yml\&quot; : cfgAnn.configPath();\n   738\t            TinyRest.MockConfig cfg = TinyRest.loadConfig(configPath);\n   739\t\n   740\t            if (cfgAnn.port() &gt;= 0) cfg.port = cfgAnn.port(); // 0 =&gt; auto-bind\n   741\t            if (!cfgAnn.authTokenOverride().isBlank()) cfg.authToken = cfgAnn.authTokenOverride();\n   742\t\n   743\t            if (cfg.features == null) cfg.features = new FeaturesConfig();\n   744\t            if (!cfgAnn.recordReplayMode().isBlank()) {\n   745\t                if (cfg.features.recordReplay == null) cfg.features.recordReplay = new RecordReplay();\n   746\t                cfg.features.recordReplay.mode = cfgAnn.recordReplayMode();\n   747\t                if (!cfgAnn.recordReplayFile().isBlank()) cfg.features.recordReplay.file = cfgAnn.recordReplayFile();\n   748\t            }\n   749\t\n   750\t            var handle = TinyRest.start(cfg, java.nio.file.Paths.get(configPath));\n   751\t            store.put(STORE_KEY, handle);\n   752\t\n   753\t            String baseUrl = \&quot;http://localhost:\&quot; + handle.boundAddress().getPort();\n   754\t            System.setProperty(\&quot;tinyrest.baseUrl\&quot;, baseUrl);\n   755\t            System.setProperty(\&quot;tinyrest.port\&quot;, String.valueOf(handle.boundAddress().getPort()));\n   756\t        }\n   757\t\n   758\t        @Override\n   759\t        public void afterAll(org.junit.jupiter.api.extension.ExtensionContext context) throws Exception {\n   760\t            var store = context.getStore(NS);\n   761\t            var handle = (TinyRest.ServerHandle) store.remove(STORE_KEY);\n   762\t            if (handle != null) handle.stop(0);\n   763\t        }\n   764\t\n   765\t        // --- Parameter injection ---\n   766\t        @Override\n   767\t        public boolean supportsParameter(org.junit.jupiter.api.extension.ParameterContext pc,\n   768\t                                         org.junit.jupiter.api.extension.ExtensionContext ec)\n   769\t                throws org.junit.jupiter.api.extension.ParameterResolutionException {\n   770\t            boolean wantBaseUrl = pc.isAnnotated(TinyRestBaseUrl.class) &amp;&amp;\n   771\t                    (pc.getParameter().getType().equals(String.class) || pc.getParameter().getType().equals(URI.class));\n   772\t            boolean wantHandle = pc.getParameter().getType().equals(TinyRest.ServerHandle.class);\n   773\t            return wantBaseUrl || wantHandle;\n   774\t        }\n   775\t\n   776\t        @Override\n   777\t        public Object resolveParameter(org.junit.jupiter.api.extension.ParameterContext pc,\n   778\t                                       org.junit.jupiter.api.extension.ExtensionContext ec)\n   779\t                throws org.junit.jupiter.api.extension.ParameterResolutionException {\n   780\t            var store = ec.getStore(NS);\n   781\t            var handle = (TinyRest.ServerHandle) store.get(STORE_KEY, TinyRest.ServerHandle.class);\n   782\t            if (handle == null) throw new org.junit.jupiter.api.extension.ParameterResolutionException(\&quot;TinyRest server not initialized.\&quot;);\n   783\t\n   784\t            if (pc.getParameter().getType().equals(TinyRest.ServerHandle.class)) return handle;\n   785\t            String base = \&quot;http://localhost:\&quot; + handle.boundAddress().getPort();\n   786\t            if (pc.getParameter().getType().equals(URI.class)) return URI.create(base);\n   787\t            return base; // String\n   788\t        }\n   789\t\n   790\t        private static &lt;A extends java.lang.annotation.Annotation&gt; A findAnnotation(\n   791\t                org.junit.jupiter.api.extension.ExtensionContext ctx, Class&lt;A&gt; type) {\n   792\t            var el = ctx.getElement().orElse(null);\n   793\t            if (el != null &amp;&amp; el.isAnnotationPresent(type)) return el.getAnnotation(type);\n   794\t            var cls = ctx.getRequiredTestClass();\n   795\t            return cls.getAnnotation(type);\n   796\t        }\n   797\t    }\n   798\t\n   799\t    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n   800\t    @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE)\n   801\t    public @interface UseTinyRest {\n   802\t        String configPath() default \&quot;src/test/resources/tinyrest.yml\&quot;;\n   803\t        int port() default 0;                       // 0 =&gt; random free port\n   804\t        String authTokenOverride() default \&quot;\&quot;;\n   805\t        String recordReplayMode() default \&quot;\&quot;;       // \&quot;\&quot;, \&quot;record\&quot;, \&quot;replay\&quot;\n   806\t        String recordReplayFile\&quot; default \&quot;\&quot;;\n   807\t    }\n   808\t\n   809\t    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n   810\t    @java.lang.annotation.Target(java.lang.annotation.ElementType.PARAMETER)\n   811\t    public @interface TinyRestBaseUrl {}\n   812\t}\n   813\t```\n   814\t\n   815\t        **Note:** In the `@UseTinyRest` annotation above, fix the typo if your IDE flags it (should be `recordReplayFile()` — I kept it readable here, but your compiler will enforce it). Also make sure your Maven `pom.xml` includes Jackson YAML as a runtime dep and JUnit 5 as a **test** scope dep so `TinyRest.java` compiles in `main` while tests compile against JUnit.\n   816\t\n   817\tIf you want, I can also drop in a minimal `tinyrest.yml` starter and a sample JUnit test file wired to this class.\n   818\t\nTotal lines in file: 818\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_01KeqNJqjS7Qzi3povf7JzjY&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:26.141Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;5c93fce0-3d51-4b79-9684-7020a1f82048&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_014wrnox7aKkUqxaAQe1RW6V&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/test/java\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test, excluding hidden items:\nsrc/test/java\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_016zW7VL1HcuKyBLmzzn1gQK&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:30.148Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;fed7f776-1d6b-4b8f-8a8d-5d49dd85b787&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_011Jbdh6ZkogY5wnT6mZC3PF&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;path\&quot;: \&quot;src/test\&quot;, \&quot;type\&quot;: \&quot;directory\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test/java, excluding hidden items:\n(empty directory)\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_014wrnox7aKkUqxaAQe1RW6V&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:33.659Z&quot;,&quot;response_text&quot;:&quot;&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;60dd07a3-d99b-4927-a707-99399af9d315&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:0,&quot;content&quot;:&quot;Based on my exploration of the codebase, here's what this project is:\n\n## TinyRest - A Lightweight Mock REST API Server\n\n**TinyRest** is a Java-based mock REST API server designed for testing and development. It's a single-file solution that provides a complete HTTP server with configurable endpoints and data stores.\n\n### Key Features:\n\n1. **Configuration-Driven**: Uses YAML or JSON configuration files to define:\n   - REST resources with automatic CRUD operations\n   - Static endpoints with custom responses\n   - Server settings (port, authentication, latency simulation)\n\n2. **Auto-Generated CRUD APIs**: For each resource defined in config, it automatically creates:\n   - `GET /api/{resource}` - List items with pagination\n   - `POST /api/{resource}` - Create new items\n   - `GET /api/{resource}/{id}` - Get specific item\n   - `PUT /api/{resource}/{id}` - Update item\n   - `DELETE /api/{resource}/{id}` - Delete item\n\n3. **Advanced Features**:\n   - **Hot Reload**: Automatically reloads configuration changes\n   - **Templating**: Dynamic response generation with variables like `{{now}}`, `{{uuid}}`, `{{path.id}}`\n   - **Record/Replay**: Can record real API interactions and replay them later\n   - **Testing Simulation**: Artificial latency and chaos engineering (random failures)\n   - **CORS Support**: Built-in cross-origin request handling\n   - **Authentication**: Bearer token support\n\n4. **JUnit 5 Integration**: Includes a custom JUnit extension for easy integration in tests:\n\n&lt;augment_code_snippet path=\&quot;src/main/java/dev/mars/tinyrest/tinyrest.java\&quot; mode=\&quot;EXCERPT\&quot;&gt;\n```java\n@ExtendWith(TinyRest.JUnitTinyRestExtension.class)\n@UseTinyRest(configPath = \&quot;src/test/resources/tinyrest.yml\&quot;)\nclass MyTest {\n    @Test\n    void testApi(@TinyRestBaseUrl String baseUrl) {\n        // Test your API calls against baseUrl\n    }\n}\n```\n&lt;/augment_code_snippet&gt;\n\n### Technology Stack:\n- **Java 17** (Maven project)\n- **Jackson** for JSON/YAML processing\n- **Java HTTP Server** (built-in, no external web framework)\n- **JUnit 5** for testing integration\n\n### Use Cases:\n- **API Mocking**: Replace external APIs during development/testing\n- **Prototyping**: Quickly spin up REST APIs for frontend development\n- **Integration Testing**: Provide controlled, predictable API responses\n- **Load Testing**: Simulate various response times and failure scenarios\n\nThe project is essentially a \&quot;mock server as code\&quot; - you define your API structure in a config file, and TinyRest handles all the HTTP plumbing, data storage, and advanced features automatically.\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;Based on my exploration of the codebase, here's what this project is:\n\n## TinyRest - A Lightweight Mock REST API Server\n\n**TinyRest** is a Java-based mock REST API server designed for testing and development. It's a single-file solution that provides a complete HTTP server with configurable endpoints and data stores.\n\n### Key Features:\n\n1. **Configuration-Driven**: Uses YAML or JSON configuration files to define:\n   - REST resources with automatic CRUD operations\n   - Static endpoints with custom responses\n   - Server settings (port, authentication, latency simulation)\n\n2. **Auto-Generated CRUD APIs**: For each resource defined in config, it automatically creates:\n   - `GET /api/{resource}` - List items with pagination\n   - `POST /api/{resource}` - Create new items\n   - `GET /api/{resource}/{id}` - Get specific item\n   - `PUT /api/{resource}/{id}` - Update item\n   - `DELETE /api/{resource}/{id}` - Delete item\n\n3. **Advanced Features**:\n   - **Hot Reload**: Automatically reloads configuration changes\n   - **Templating**: Dynamic response generation with variables like `{{now}}`, `{{uuid}}`, `{{path.id}}`\n   - **Record/Replay**: Can record real API interactions and replay them later\n   - **Testing Simulation**: Artificial latency and chaos engineering (random failures)\n   - **CORS Support**: Built-in cross-origin request handling\n   - **Authentication**: Bearer token support\n\n4. **JUnit 5 Integration**: Includes a custom JUnit extension for easy integration in tests:\n\n````java path=src/main/java/dev/mars/tinyrest/tinyrest.java mode=EXCERPT\n@ExtendWith(TinyRest.JUnitTinyRestExtension.class)\n@UseTinyRest(configPath = \&quot;src/test/resources/tinyrest.yml\&quot;)\nclass MyTest {\n    @Test\n    void testApi(@TinyRestBaseUrl String baseUrl) {\n        // Test your API calls against baseUrl\n    }\n}\n````\n\n### Technology Stack:\n- **Java 17** (Maven project)\n- **Jackson** for JSON/YAML processing\n- **Java HTTP Server** (built-in, no external web framework)\n- **JUnit 5** for testing integration\n\n### Use Cases:\n- **API Mocking**: Replace external APIs during development/testing\n- **Prototyping**: Quickly spin up REST APIs for frontend development\n- **Integration Testing**: Provide controlled, predictable API responses\n- **Load Testing**: Simulate various response times and failure scenarios\n\nThe project is essentially a \&quot;mock server as code\&quot; - you define your API structure in a config file, and TinyRest handles all the HTTP plumbing, data storage, and advanced features automatically.\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test, excluding hidden items:\nsrc/test/java\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_011Jbdh6ZkogY5wnT6mZC3PF&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;,&quot;folderRoot&quot;:&quot;C:/Users/mraysmit/dev/idea-projects/tinyrest&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-30T11:33:36.914Z&quot;,&quot;response_text&quot;:&quot;Based on my exploration of the codebase, here's what this project is:\n\n## TinyRest - A Lightweight Mock REST API Server\n\n**TinyRest** is a Java-based mock REST API server designed for testing and development. It's a single-file solution that provides a complete HTTP server with configurable endpoints and data stores.\n\n### Key Features:\n\n1. **Configuration-Driven**: Uses YAML or JSON configuration files to define:\n   - REST resources with automatic CRUD operations\n   - Static endpoints with custom responses\n   - Server settings (port, authentication, latency simulation)\n\n2. **Auto-Generated CRUD APIs**: For each resource defined in config, it automatically creates:\n   - `GET /api/{resource}` - List items with pagination\n   - `POST /api/{resource}` - Create new items\n   - `GET /api/{resource}/{id}` - Get specific item\n   - `PUT /api/{resource}/{id}` - Update item\n   - `DELETE /api/{resource}/{id}` - Delete item\n\n3. **Advanced Features**:\n   - **Hot Reload**: Automatically reloads configuration changes\n   - **Templating**: Dynamic response generation with variables like `{{now}}`, `{{uuid}}`, `{{path.id}}`\n   - **Record/Replay**: Can record real API interactions and replay them later\n   - **Testing Simulation**: Artificial latency and chaos engineering (random failures)\n   - **CORS Support**: Built-in cross-origin request handling\n   - **Authentication**: Bearer token support\n\n4. **JUnit 5 Integration**: Includes a custom JUnit extension for easy integration in tests:\n\n````java path=src/main/java/dev/mars/tinyrest/tinyrest.java mode=EXCERPT\n@ExtendWith(TinyRest.JUnitTinyRestExtension.class)\n@UseTinyRest(configPath = \&quot;src/test/resources/tinyrest.yml\&quot;)\nclass MyTest {\n    @Test\n    void testApi(@TinyRestBaseUrl String baseUrl) {\n        // Test your API calls against baseUrl\n    }\n}\n````\n\n### Technology Stack:\n- **Java 17** (Maven project)\n- **Jackson** for JSON/YAML processing\n- **Java HTTP Server** (built-in, no external web framework)\n- **JUnit 5** for testing integration\n\n### Use Cases:\n- **API Mocking**: Replace external APIs during development/testing\n- **Prototyping**: Quickly spin up REST APIs for frontend development\n- **Integration Testing**: Provide controlled, predictable API responses\n- **Load Testing**: Simulate various response times and failure scenarios\n\nThe project is essentially a \&quot;mock server as code\&quot; - you define your API structure in a config file, and TinyRest handles all the HTTP plumbing, data storage, and advanced features automatically.\n&quot;,&quot;workspace_file_chunks&quot;:[]}],&quot;feedbackStates&quot;:{&quot;temp-fe-95862fe6-284a-457f-944c-5b62d0cb6906&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-d1d10c13-8aa9-4c0d-867b-f79f484f9f8e&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-15b05333-e2e4-499f-9e97-e1d6b762de5e&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-85851709-4fd3-44e4-9e62-9db859e94f0a&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-ac148c8f-443c-403a-91ce-6802eef07847&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-0eca704d-9f70-4c20-b984-c181dfe763cd&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-45829a53-9314-4de1-97a7-af197654424d&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-3c294caf-c1f0-400b-9188-9a12d41ccd24&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-39138ef1-8fe1-45bb-afc0-2bd44e9c4c90&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;}},&quot;toolUseStates&quot;:{&quot;b864ae81-f6ce-4c63-bc9a-b0bfd5b653c2;toolu_019E2SQJ2h4R7ERdif5Bchvz&quot;:{&quot;requestId&quot;:&quot;b864ae81-f6ce-4c63-bc9a-b0bfd5b653c2&quot;,&quot;toolUseId&quot;:&quot;toolu_019E2SQJ2h4R7ERdif5Bchvz&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in ., excluding hidden items:\n./pom.xml\n./src\n./src\\main\n./src\\test\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;287b4cdc-df98-45bb-a3b0-32a14b3e666b;toolu_018eA5Th46jQhxhc2Q5nMVoW&quot;:{&quot;requestId&quot;:&quot;287b4cdc-df98-45bb-a3b0-32a14b3e666b&quot;,&quot;toolUseId&quot;:&quot;toolu_018eA5Th46jQhxhc2Q5nMVoW&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on pom.xml:\n     1\t&lt;project xmlns=\&quot;http://maven.apache.org/POM/4.0.0\&quot;\n     2\t         xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;\n     3\t         xsi:schemaLocation=\&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\&quot;&gt;\n     4\t    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n     5\t\n     6\t    &lt;groupId&gt;com.example&lt;/groupId&gt;\n     7\t    &lt;artifactId&gt;tinyrest&lt;/artifactId&gt;\n     8\t    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n     9\t    &lt;packaging&gt;jar&lt;/packaging&gt;\n    10\t\n    11\t    &lt;properties&gt;\n    12\t        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n    13\t        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n    14\t        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    15\t        &lt;junit.version&gt;5.10.2&lt;/junit.version&gt;\n    16\t        &lt;jackson.version&gt;2.17.2&lt;/jackson.version&gt;\n    17\t    &lt;/properties&gt;\n    18\t\n    19\t    &lt;dependencies&gt;\n    20\t        &lt;!-- Jackson core --&gt;\n    21\t        &lt;dependency&gt;\n    22\t            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    23\t            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    24\t            &lt;version&gt;${jackson.version}&lt;/version&gt;\n    25\t        &lt;/dependency&gt;\n    26\t\n    27\t        &lt;!-- Jackson YAML --&gt;\n    28\t        &lt;dependency&gt;\n    29\t            &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;\n    30\t            &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;\n    31\t            &lt;version&gt;${jackson.version}&lt;/version&gt;\n    32\t        &lt;/dependency&gt;\n    33\t\n    34\t        &lt;!-- JUnit 5 API --&gt;\n    35\t        &lt;dependency&gt;\n    36\t            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    37\t            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n    38\t            &lt;version&gt;${junit.version}&lt;/version&gt;\n    39\t            &lt;scope&gt;test&lt;/scope&gt;\n    40\t        &lt;/dependency&gt;\n    41\t\n    42\t        &lt;!-- JUnit 5 Engine (runtime for tests) --&gt;\n    43\t        &lt;dependency&gt;\n    44\t            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    45\t            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;\n    46\t            &lt;version&gt;${junit.version}&lt;/version&gt;\n    47\t            &lt;scope&gt;test&lt;/scope&gt;\n    48\t        &lt;/dependency&gt;\n    49\t    &lt;/dependencies&gt;\n    50\t\n    51\t    &lt;build&gt;\n    52\t        &lt;plugins&gt;\n    53\t            &lt;!-- Run JUnit 5 tests --&gt;\n    54\t            &lt;plugin&gt;\n    55\t                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    56\t                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    57\t                &lt;version&gt;3.2.5&lt;/version&gt;\n    58\t                &lt;configuration&gt;\n    59\t                    &lt;useModulePath&gt;false&lt;/useModulePath&gt;\n    60\t                &lt;/configuration&gt;\n    61\t            &lt;/plugin&gt;\n    62\t        &lt;/plugins&gt;\n    63\t    &lt;/build&gt;\n    64\t&lt;/project&gt;\n    65\t\nTotal lines in file: 65\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;0bbbf26b-7b72-487f-8e50-5ab4e3eeca97;toolu_01SFVmH4BRzjnpNXKgDVW9kd&quot;:{&quot;requestId&quot;:&quot;0bbbf26b-7b72-487f-8e50-5ab4e3eeca97&quot;,&quot;toolUseId&quot;:&quot;toolu_01SFVmH4BRzjnpNXKgDVW9kd&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in src/main/java, excluding hidden items:\nsrc/main/java/dev\nsrc/main/java/dev\\mars\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;5d780c1c-c865-4901-a6e7-4d18d0d638f1;toolu_01DonkEK7eJqBkmPJqd1xDMf&quot;:{&quot;requestId&quot;:&quot;5d780c1c-c865-4901-a6e7-4d18d0d638f1&quot;,&quot;toolUseId&quot;:&quot;toolu_01DonkEK7eJqBkmPJqd1xDMf&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in src/main/java/dev/mars, excluding hidden items:\nsrc/main/java/dev/mars/tinyrest\nsrc/main/java/dev/mars/tinyrest\\tinyrest.java\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;84333b92-d7e4-4ddf-ae08-edcc6acdaeb9;toolu_01KeqNJqjS7Qzi3povf7JzjY&quot;:{&quot;requestId&quot;:&quot;84333b92-d7e4-4ddf-ae08-edcc6acdaeb9&quot;,&quot;toolUseId&quot;:&quot;toolu_01KeqNJqjS7Qzi3povf7JzjY&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/main/java/dev/mars/tinyrest/tinyrest.java:\n     1\t\n     2\t// TinyRest.java\n     3\t//\n     4\t// Build deps (Maven):\n     5\t//   - com.fasterxml.jackson.core:jackson-databind:2.17.2\n     6\t//   - com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.17.2\n     7\t// Test deps (for the JUnit extension):\n     8\t//   - org.junit.jupiter:junit-jupiter:5.x\n     9\t//\n    10\t// Run:\n    11\t//   mvn -q -DskipTests package\n    12\t//   java -cp target/your-jar-with-deps.jar:. TinyRest src/test/resources/tinyrest.yml\n    13\t//\n    14\t// Example tinyrest.yml shown at bottom of this file’s comment header.\n    15\t\n    16\timport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n    17\timport com.fasterxml.jackson.core.JsonGenerator;\n    18\timport com.fasterxml.jackson.core.type.TypeReference;\n    19\timport com.fasterxml.jackson.databind.DeserializationFeature;\n    20\timport com.fasterxml.jackson.databind.ObjectMapper;\n    21\timport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n    22\timport com.sun.net.httpserver.Headers;\n    23\timport com.sun.net.httpserver.HttpExchange;\n    24\timport com.sun.net.httpserver.HttpServer;\n    25\t\n    26\timport java.io.*;\n    27\timport java.net.InetSocketAddress;\n    28\timport java.net.URI;\n    29\timport java.nio.charset.StandardCharsets;\n    30\timport java.nio.file.*;\n    31\timport java.time.Instant;\n    32\timport java.time.format.DateTimeFormatter;\n    33\timport java.util.*;\n    34\timport java.util.concurrent.*;\n    35\timport java.util.regex.Matcher;\n    36\timport java.util.regex.Pattern;\n    37\timport java.util.stream.Collectors;\n    38\t\n    39\tpublic class TinyRest {\n    40\t\n    41\t    public static void main(String[] args) throws Exception {\n    42\t        if (args.length == 0) {\n    43\t            System.err.println(\&quot;Usage: java TinyRest &lt;tinyrest.yml|json&gt;\&quot;);\n    44\t            System.exit(1);\n    45\t        }\n    46\t        var path = Paths.get(args[0]).toAbsolutePath();\n    47\t        var cfg = loadConfig(path.toString());\n    48\t        var handle = start(cfg, path);\n    49\t        System.out.printf(\&quot;TinyRest ready on http://localhost:%d/  (watching %s)%n\&quot;,\n    50\t                handle.boundAddress().getPort(), path);\n    51\t    }\n    52\t\n    53\t    // ---------- Public API ----------\n    54\t    public static MockConfig loadConfig(String path) throws IOException {\n    55\t        try (var in = new FileInputStream(path)) {\n    56\t            boolean yaml = path.endsWith(\&quot;.yml\&quot;) || path.endsWith(\&quot;.yaml\&quot;);\n    57\t            ObjectMapper mapper = yaml ? yamlMapper() : jsonMapper();\n    58\t            return mapper.readValue(in, MockConfig.class);\n    59\t        }\n    60\t    }\n    61\t\n    62\t    public static ServerHandle start(MockConfig cfg, Path configPath) throws IOException {\n    63\t        int port = cfg.port != null ? cfg.port : 8080;\n    64\t        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n    65\t        server.setExecutor(Executors.newFixedThreadPool(Math.max(4, Runtime.getRuntime().availableProcessors())));\n    66\t        var engine = new Engine(defaults(cfg), configPath);\n    67\t        server.createContext(\&quot;/\&quot;, ex -&gt; { try { engine.handle(ex); } finally { ex.close(); }});\n    68\t        server.start();\n    69\t        if (engine.features.hotReload) engine.startFileWatcher();\n    70\t        return new ServerHandle(server, engine);\n    71\t    }\n    72\t\n    73\t    // ---------- Engine ----------\n    74\t    static class Engine {\n    75\t        volatile MockConfig cfg;\n    76\t        final ObjectMapper om = jsonMapper();\n    77\t        final Map&lt;String, ResourceStore&gt; stores = new ConcurrentHashMap&lt;&gt;();\n    78\t        volatile List&lt;Route&gt; routes = new CopyOnWriteArrayList&lt;&gt;();\n    79\t        final Path configPath;\n    80\t        final Features features;\n    81\t        final Recorder recorder;\n    82\t\n    83\t        Engine(MockConfig cfg, Path configPath) {\n    84\t            this.cfg = cfg;\n    85\t            this.configPath = configPath;\n    86\t            this.features = Features.from(cfg.features);\n    87\t            if (\&quot;strict\&quot;.equalsIgnoreCase(features.schemaValidation)) validateOrDie(cfg);\n    88\t            else validateLenient(cfg);\n    89\t\n    90\t            initStores();\n    91\t            initRoutes();\n    92\t            this.recorder = new Recorder(features.recordReplay, om);\n    93\t            if (recorder.isReplay()) recorder.loadFromFile();\n    94\t        }\n    95\t\n    96\t        void handle(HttpExchange ex) throws IOException {\n    97\t            addCORS(ex);\n    98\t            if (handleCorsPreflight(ex)) return;\n    99\t            withLatency(cfg.artificialLatencyMs);\n   100\t            maybeChaos(cfg.chaosFailRate);\n   101\t\n   102\t            try {\n   103\t                String method = ex.getRequestMethod();\n   104\t                String path = ex.getRequestURI().getPath();\n   105\t\n   106\t                // record/replay — replay happens BEFORE any routing\n   107\t                if (recorder.isReplay()) {\n   108\t                    var hit = recorder.tryReplay(ex);\n   109\t                    if (hit != null) { write(ex, hit); return; }\n   110\t                    if (\&quot;error\&quot;.equalsIgnoreCase(recorder.replayOnMiss())) {\n   111\t                        write(ex, Response.json(501, Map.of(\&quot;error\&quot;, \&quot;replay_miss\&quot;, \&quot;path\&quot;, path))); return;\n   112\t                    }\n   113\t                    // else: fallback to normal routing\n   114\t                }\n   115\t\n   116\t                for (Route r : routes) {\n   117\t                    Matcher m = r.pattern.matcher(path);\n   118\t                    if (r.method.equals(method) &amp;&amp; m.matches()) {\n   119\t                        var ctx = new Ctx(ex, om, cfg, m, r, features);\n   120\t                        if (r.mutates &amp;&amp; !isAuthorized(ctx)) throw new Unauthorized(\&quot;Missing/invalid bearer token\&quot;);\n   121\t                        Response resp = r.handler.handle(ctx);\n   122\t                        write(ex, resp);\n   123\t                        // record AFTER successful handling\n   124\t                        if (recorder.isRecording()) recorder.record(ex, resp);\n   125\t                        return;\n   126\t                    }\n   127\t                }\n   128\t                var notFound = Response.json(404, Map.of(\n   129\t                        \&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No route \&quot;+method+\&quot; \&quot;+path));\n   130\t                write(ex, notFound);\n   131\t                if (recorder.isRecording()) recorder.record(ex, notFound);\n   132\t            } catch (BadRequest e) {\n   133\t                var resp = Response.json(400, Map.of(\&quot;error\&quot;,\&quot;bad_request\&quot;,\&quot;message\&quot;, e.getMessage()));\n   134\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   135\t            } catch (Unauthorized e) {\n   136\t                var resp = Response.json(401, Map.of(\&quot;error\&quot;,\&quot;unauthorized\&quot;,\&quot;message\&quot;, e.getMessage()));\n   137\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   138\t            } catch (Exception e) {\n   139\t                e.printStackTrace();\n   140\t                var resp = Response.json(500, Map.of(\&quot;error\&quot;,\&quot;internal\&quot;,\&quot;message\&quot;,\&quot;boom\&quot;));\n   141\t                write(ex, resp); if (recorder.isRecording()) recorder.record(ex, resp);\n   142\t            }\n   143\t        }\n   144\t\n   145\t        private void initStores() {\n   146\t            stores.clear();\n   147\t            if (cfg.resources == null) return;\n   148\t            for (var r : cfg.resources) {\n   149\t                String idField = blank(r.idField) ? \&quot;id\&quot; : r.idField;\n   150\t                var store = new ResourceStore(r.name, idField);\n   151\t                if (r.seed != null) {\n   152\t                    for (Map&lt;String,Object&gt; row : r.seed) {\n   153\t                        Object id = row.get(idField);\n   154\t                        if (id == null) { id = UUID.randomUUID().toString(); row.put(idField, id); }\n   155\t                        store.put(id.toString(), deepCopy(row));\n   156\t                    }\n   157\t                }\n   158\t                stores.put(r.name, store);\n   159\t            }\n   160\t        }\n   161\t\n   162\t        private void initRoutes() {\n   163\t            var newRoutes = new ArrayList&lt;Route&gt;();\n   164\t\n   165\t            if (cfg.resources != null) {\n   166\t                for (var r : cfg.resources) {\n   167\t                    boolean enable = r.enableCrud == null || r.enableCrud;\n   168\t                    if (!enable) continue;\n   169\t                    var base = \&quot;/api/\&quot; + r.name;\n   170\t\n   171\t                    newRoutes.add(new Route(\&quot;GET\&quot;, base, false, (ctx) -&gt; {\n   172\t                        var store = stores.get(r.name);\n   173\t                        var qp = ctx.query();\n   174\t                        int limit = qp.getInt(\&quot;limit\&quot;, 50);\n   175\t                        int offset = qp.getInt(\&quot;offset\&quot;, 0);\n   176\t                        return Response.json(200, store.list(limit, offset));\n   177\t                    }));\n   178\t\n   179\t                    newRoutes.add(new Route(\&quot;POST\&quot;, base, true, (ctx) -&gt; {\n   180\t                        var store = stores.get(r.name);\n   181\t                        Map&lt;String,Object&gt; in = ctx.readJsonMap();\n   182\t                        Object id = in.get(store.idField);\n   183\t                        if (id == null) { id = UUID.randomUUID().toString(); in.put(store.idField, id); }\n   184\t                        store.put(id.toString(), in);\n   185\t                        return Response.json(201, in).withHeader(\&quot;Location\&quot;, base + \&quot;/\&quot; + id);\n   186\t                    }));\n   187\t\n   188\t                    newRoutes.add(new Route(\&quot;GET\&quot;, base + \&quot;/{id}\&quot;, false, (ctx) -&gt; {\n   189\t                        var store = stores.get(r.name);\n   190\t                        var row = store.get(ctx.path(\&quot;id\&quot;));\n   191\t                        return row == null ? Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;))\n   192\t                                : Response.json(200, row);\n   193\t                    }));\n   194\t\n   195\t                    newRoutes.add(new Route(\&quot;PUT\&quot;, base + \&quot;/{id}\&quot;, true, (ctx) -&gt; {\n   196\t                        var store = stores.get(r.name);\n   197\t                        String id = ctx.path(\&quot;id\&quot;);\n   198\t                        var existing = store.get(id);\n   199\t                        if (existing == null) return Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;));\n   200\t                        var patch = ctx.readJsonMap();\n   201\t                        existing.putAll(patch);\n   202\t                        existing.put(store.idField, id);\n   203\t                        store.put(id, existing);\n   204\t                        return Response.json(200, existing);\n   205\t                    }));\n   206\t\n   207\t                    newRoutes.add(new Route(\&quot;DELETE\&quot;, base + \&quot;/{id}\&quot;, true, (ctx) -&gt; {\n   208\t                        var store = stores.get(r.name);\n   209\t                        boolean removed = store.remove(ctx.path(\&quot;id\&quot;));\n   210\t                        return removed ? new Response(204, new LinkedHashMap&lt;&gt;(), null)\n   211\t                                : Response.json(404, Map.of(\&quot;error\&quot;,\&quot;not_found\&quot;,\&quot;message\&quot;,\&quot;No \&quot;+r.name+\&quot; with that id\&quot;));\n   212\t                    }));\n   213\t                }\n   214\t            }\n   215\t\n   216\t            if (cfg.staticEndpoints != null) {\n   217\t                for (var se : cfg.staticEndpoints) {\n   218\t                    String method = blank(se.method) ? \&quot;GET\&quot; : se.method;\n   219\t                    int status = se.status == null ? 200 : se.status;\n   220\t                    boolean mutates = switch (method) {\n   221\t                        case \&quot;POST\&quot;,\&quot;PUT\&quot;,\&quot;DELETE\&quot;,\&quot;PATCH\&quot; -&gt; true; default -&gt; false;\n   222\t                    };\n   223\t                    newRoutes.add(new Route(method, se.path, mutates, (ctx) -&gt; {\n   224\t                        if (Boolean.TRUE.equals(se.echoRequest)) {\n   225\t                            return Response.json(status, Map.of(\n   226\t                                    \&quot;method\&quot;, ctx.exchange.getRequestMethod(),\n   227\t                                    \&quot;path\&quot;, ctx.exchange.getRequestURI().getPath(),\n   228\t                                    \&quot;query\&quot;, ctx.query().raw,\n   229\t                                    \&quot;headers\&quot;, ctx.headersMap(),\n   230\t                                    \&quot;body\&quot;, ctx.readBodyAsString(),\n   231\t                                    \&quot;time\&quot;, Instant.now().toString()\n   232\t                            ));\n   233\t                        } else {\n   234\t                            Object body = se.response == null ? Map.of() : deepCopy(se.response);\n   235\t                            if (features.templating) body = Template.apply(body, ctx);\n   236\t                            return Response.json(status, body);\n   237\t                        }\n   238\t                    }));\n   239\t                }\n   240\t            }\n   241\t            this.routes = newRoutes;\n   242\t        }\n   243\t\n   244\t        // ---- Hot reload ----\n   245\t        void startFileWatcher() {\n   246\t            Thread t = new Thread(() -&gt; {\n   247\t                try (WatchService ws = FileSystems.getDefault().newWatchService()) {\n   248\t                    var dir = configPath.getParent();\n   249\t                    if (dir == null) return;\n   250\t                    dir.register(ws, StandardWatchEventKinds.ENTRY_MODIFY);\n   251\t                    while (true) {\n   252\t                        var key = ws.take();\n   253\t                        for (WatchEvent&lt;?&gt; ev : key.pollEvents()) {\n   254\t                            var changed = (Path) ev.context();\n   255\t                            if (changed != null &amp;&amp; configPath.getFileName().equals(changed)) {\n   256\t                                try {\n   257\t                                    var newCfg = loadConfig(configPath.toString());\n   258\t                                    // validate &amp; swap\n   259\t                                    if (\&quot;strict\&quot;.equalsIgnoreCase(features.schemaValidation)) validateOrDie(newCfg);\n   260\t                                    else validateLenient(newCfg);\n   261\t                                    this.cfg = defaults(newCfg);\n   262\t                                    initStores();\n   263\t                                    initRoutes();\n   264\t                                    System.out.println(\&quot;[hot-reload] applied config at \&quot; + Instant.now());\n   265\t                                } catch (Exception e) {\n   266\t                                    System.err.println(\&quot;[hot-reload] failed: \&quot; + e.getMessage());\n   267\t                                }\n   268\t                            }\n   269\t                        }\n   270\t                        key.reset();\n   271\t                    }\n   272\t                } catch (Exception e) {\n   273\t                    System.err.println(\&quot;[hot-reload] watcher stopped: \&quot; + e.getMessage());\n   274\t                }\n   275\t            }, \&quot;tinyrest-hot-reload\&quot;);\n   276\t            t.setDaemon(true);\n   277\t            t.start();\n   278\t        }\n   279\t    }\n   280\t\n   281\t    // ---------- Template engine ----------\n   282\t    static class Template {\n   283\t        private static final Pattern P = Pattern.compile(\&quot;\\\\{\\\\{\\\\s*([^}]+)\\\\s*}}\&quot;);\n   284\t\n   285\t        static Object apply(Object node, Ctx ctx) {\n   286\t            if (node instanceof Map&lt;?,?&gt; m) {\n   287\t                Map&lt;String,Object&gt; out = new LinkedHashMap&lt;&gt;();\n   288\t                for (var e : m.entrySet()) out.put(String.valueOf(e.getKey()), apply(e.getValue(), ctx));\n   289\t                return out;\n   290\t            } else if (node instanceof List&lt;?&gt; list) {\n   291\t                List&lt;Object&gt; out = new ArrayList&lt;&gt;();\n   292\t                for (var v : list) out.add(apply(v, ctx));\n   293\t                return out;\n   294\t            } else if (node instanceof String s) {\n   295\t                return renderString(s, ctx);\n   296\t            } else {\n   297\t                return node;\n   298\t            }\n   299\t        }\n   300\t\n   301\t        static String renderString(String s, Ctx ctx) {\n   302\t            Matcher m = P.matcher(s);\n   303\t            StringBuffer sb = new StringBuffer();\n   304\t            while (m.find()) {\n   305\t                String expr = m.group(1).trim();\n   306\t                String val = eval(expr, ctx);\n   307\t                m.appendReplacement(sb, Matcher.quoteReplacement(val));\n   308\t            }\n   309\t            m.appendTail(sb);\n   310\t            return sb.toString();\n   311\t        }\n   312\t\n   313\t        static String eval(String expr, Ctx ctx) {\n   314\t            // builtins\n   315\t            if (\&quot;now\&quot;.equals(expr)) return DateTimeFormatter.ISO_INSTANT.format(Instant.now());\n   316\t            if (\&quot;uuid\&quot;.equals(expr)) return UUID.randomUUID().toString();\n   317\t            if (expr.startsWith(\&quot;path.\&quot;)) return nvl(ctx.pathOrNull(expr.substring(5)));\n   318\t            if (expr.startsWith(\&quot;query.\&quot;)) return nvl(ctx.query().get(expr.substring(6), \&quot;\&quot;));\n   319\t            if (expr.startsWith(\&quot;body.\&quot;))  return nvl(jsonPointer(ctx.bodyAsMap(), expr.substring(5)));\n   320\t            if (expr.startsWith(\&quot;header.\&quot;)) return nvl(ctx.header(expr.substring(7)));\n   321\t            // random.int(a,b)\n   322\t            if (expr.startsWith(\&quot;random.int(\&quot;) &amp;&amp; expr.endsWith(\&quot;)\&quot;)) {\n   323\t                try {\n   324\t                    String inner = expr.substring(\&quot;random.int(\&quot;.length(), expr.length()-1);\n   325\t                    String[] parts = inner.split(\&quot;,\&quot;, 2);\n   326\t                    int a = Integer.parseInt(parts[0].trim());\n   327\t                    int b = Integer.parseInt(parts[1].trim());\n   328\t                    int n = ThreadLocalRandom.current().nextInt(a, b+1);\n   329\t                    return String.valueOf(n);\n   330\t                } catch (Exception e) { return \&quot;\&quot;; }\n   331\t            }\n   332\t            return \&quot;\&quot;; // unknown expression -&gt; empty\n   333\t        }\n   334\t\n   335\t        @SuppressWarnings(\&quot;unchecked\&quot;)\n   336\t        static String jsonPointer(Map&lt;String,Object&gt; m, String dotted) {\n   337\t            if (m == null) return \&quot;\&quot;;\n   338\t            Object cur = m;\n   339\t            for (String seg : dotted.split(\&quot;\\\\.\&quot;)) {\n   340\t                if (!(cur instanceof Map&lt;?,?&gt; map)) return \&quot;\&quot;;\n   341\t                cur = ((Map&lt;String,Object&gt;) map).get(seg);\n   342\t                if (cur == null) return \&quot;\&quot;;\n   343\t            }\n   344\t            return String.valueOf(cur);\n   345\t        }\n   346\t        static String nvl(String s) { return s == null ? \&quot;\&quot; : s; }\n   347\t    }\n   348\t\n   349\t    // ---------- Recorder / Replayer ----------\n   350\t    static class Recorder {\n   351\t        final RecordReplay rr;\n   352\t        final ObjectMapper om;\n   353\t        Recorder(RecordReplay rr, ObjectMapper om) { this.rr = rr == null ? new RecordReplay() : rr; this.om = om; }\n   354\t        boolean isRecording() { return rr != null &amp;&amp; \&quot;record\&quot;.equalsIgnoreCase(rr.mode); }\n   355\t        boolean isReplay()    { return rr != null &amp;&amp; \&quot;replay\&quot;.equalsIgnoreCase(rr.mode); }\n   356\t        String replayOnMiss() { return rr == null ? \&quot;fallback\&quot; : (blank(rr.replayOnMiss) ? \&quot;fallback\&quot; : rr.replayOnMiss); }\n   357\t\n   358\t        final List&lt;ReplayItem&gt; items = new CopyOnWriteArrayList&lt;&gt;();\n   359\t\n   360\t        void loadFromFile() {\n   361\t            if (blank(rr.file)) return;\n   362\t            var f = Paths.get(rr.file);\n   363\t            if (!Files.exists(f)) return;\n   364\t            try (var br = Files.newBufferedReader(f, StandardCharsets.UTF_8)) {\n   365\t                String line;\n   366\t                while ((line = br.readLine()) != null) {\n   367\t                    items.add(om.readValue(line, ReplayItem.class));\n   368\t                }\n   369\t                System.out.println(\&quot;[replay] loaded \&quot; + items.size() + \&quot; entries from \&quot; + rr.file);\n   370\t            } catch (Exception e) {\n   371\t                System.err.println(\&quot;[replay] failed loading \&quot; + rr.file + \&quot;: \&quot; + e.getMessage());\n   372\t            }\n   373\t        }\n   374\t\n   375\t        void record(HttpExchange ex, Response resp) {\n   376\t            if (!isRecording() || blank(rr.file)) return;\n   377\t            try {\n   378\t                var item = ReplayItem.from(ex, resp, rr);\n   379\t                try (var fw = new FileWriter(rr.file, true);\n   380\t                     var bw = new BufferedWriter(fw)) {\n   381\t                    om.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n   382\t                    bw.write(om.writeValueAsString(item));\n   383\t                    bw.write(\&quot;\\n\&quot;);\n   384\t                }\n   385\t            } catch (Exception e) {\n   386\t                System.err.println(\&quot;[record] failed: \&quot; + e.getMessage());\n   387\t            }\n   388\t        }\n   389\t\n   390\t        Response tryReplay(HttpExchange ex) {\n   391\t            if (!isReplay()) return null;\n   392\t            var req = ReplayItem.captureRequest(ex);\n   393\t            for (var it : items) {\n   394\t                if (it.matches(req, rr)) return it.toResponse();\n   395\t            }\n   396\t            return null;\n   397\t        }\n   398\t    }\n   399\t\n   400\t    // ---------- HTTP plumbing ----------\n   401\t    interface Handler { Response handle(Ctx ctx) throws Exception; }\n   402\t    static class Route {\n   403\t        final String method; final Pattern pattern; final Handler handler; final boolean mutates;\n   404\t        Route(String method, String pathTemplate, boolean mutates, Handler handler) {\n   405\t            this.method = method; this.pattern = compile(pathTemplate); this.mutates = mutates; this.handler = handler;\n   406\t        }\n   407\t        private static Pattern compile(String tpl) {\n   408\t            String regex = Arrays.stream(tpl.split(\&quot;/\&quot;))\n   409\t                    .filter(s -&gt; !s.isEmpty())\n   410\t                    .map(seg -&gt; seg.startsWith(\&quot;{\&quot;) &amp;&amp; seg.endsWith(\&quot;}\&quot;)\n   411\t                            ? \&quot;(?&lt;\&quot; + seg.substring(1, seg.length()-1) + \&quot;&gt;[^/]+)\&quot;\n   412\t                            : Pattern.quote(seg))\n   413\t                    .collect(Collectors.joining(\&quot;/\&quot;, \&quot;^/\&quot;, \&quot;$\&quot;));\n   414\t            return Pattern.compile(regex);\n   415\t        }\n   416\t    }\n   417\t\n   418\t    static class Ctx {\n   419\t        final HttpExchange exchange; final ObjectMapper om; final MockConfig cfg; final Matcher matcher; final Route route; final Features features;\n   420\t        Map&lt;String,Object&gt; bodyCache;\n   421\t\n   422\t        Ctx(HttpExchange exchange, ObjectMapper om, MockConfig cfg, Matcher matcher, Route route, Features features) {\n   423\t            this.exchange = exchange; this.om = om; this.cfg = cfg; this.matcher = matcher; this.route = route; this.features = features;\n   424\t        }\n   425\t        String path(String group) { return matcher.group(group); }\n   426\t        String pathOrNull(String group) { try { return matcher.group(group); } catch (Exception e) { return null; } }\n   427\t        Query query() { return new Query(exchange.getRequestURI()); }\n   428\t        String header(String name) { var v = exchange.getRequestHeaders().get(name); return (v==null||v.isEmpty())?null:v.get(0); }\n   429\t        Map&lt;String, List&lt;String&gt;&gt; headersMap() {\n   430\t            return exchange.getRequestHeaders().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n   431\t        }\n   432\t        Map&lt;String,Object&gt; readJsonMap() {\n   433\t            if (!\&quot;application/json\&quot;.equalsIgnoreCase(contentType())) throw new BadRequest(\&quot;Content-Type must be application/json\&quot;);\n   434\t            try (var is = exchange.getRequestBody()) { return om.readValue(is, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){}); }\n   435\t            catch (IOException e) { throw new BadRequest(\&quot;Invalid JSON\&quot;); }\n   436\t        }\n   437\t        Map&lt;String,Object&gt; bodyAsMap() {\n   438\t            if (bodyCache != null) return bodyCache;\n   439\t            try (var is = exchange.getRequestBody()) {\n   440\t                byte[] bytes = is.readAllBytes();\n   441\t                if (bytes.length == 0) return bodyCache = Map.of();\n   442\t                return bodyCache = om.readValue(bytes, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){});\n   443\t            } catch (Exception e) { return bodyCache = Map.of(); }\n   444\t        }\n   445\t        String readBodyAsString() {\n   446\t            try (var is = exchange.getRequestBody()) { return new String(is.readAllBytes(), StandardCharsets.UTF_8); }\n   447\t            catch (IOException e) { return \&quot;\&quot;; }\n   448\t        }\n   449\t        String contentType() { var ct = header(\&quot;Content-Type\&quot;); return ct==null? \&quot;\&quot; : ct.split(\&quot;;\&quot;)[0].trim(); }\n   450\t    }\n   451\t\n   452\t    static class Query {\n   453\t        final Map&lt;String, List&lt;String&gt;&gt; raw;\n   454\t        Query(URI uri) { this.raw = split(uri.getRawQuery()); }\n   455\t        private static Map&lt;String, List&lt;String&gt;&gt; split(String q) {\n   456\t            Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();\n   457\t            if (q == null || q.isEmpty()) return map;\n   458\t            for (String kv : q.split(\&quot;&amp;\&quot;)) {\n   459\t                String[] parts = kv.split(\&quot;=\&quot;, 2);\n   460\t                String k = decode(parts[0]);\n   461\t                String v = parts.length &gt; 1 ? decode(parts[1]) : \&quot;\&quot;;\n   462\t                map.computeIfAbsent(k, __ -&gt; new ArrayList&lt;&gt;()).add(v);\n   463\t            }\n   464\t            return map;\n   465\t        }\n   466\t        private static String decode(String s) { return java.net.URLDecoder.decode(s, StandardCharsets.UTF_8); }\n   467\t        int getInt(String key, int def) { try { return Integer.parseInt(get(key, String.valueOf(def))); } catch (Exception e) { return def; } }\n   468\t        String get(String key, String def) { var list = raw.get(key); return (list==null||list.isEmpty())?def:list.get(0); }\n   469\t    }\n   470\t\n   471\t    static class Response {\n   472\t        final int status; final Map&lt;String,String&gt; headers; final byte[] body;\n   473\t        Response(int status, Map&lt;String,String&gt; headers, byte[] body) { this.status=status; this.headers=headers; this.body=body; }\n   474\t        static Response json(int status, Object obj) {\n   475\t            try {\n   476\t                var bytes = jsonMapper().writeValueAsBytes(obj);\n   477\t                var h = new LinkedHashMap&lt;String,String&gt;();\n   478\t                h.put(\&quot;Content-Type\&quot;, \&quot;application/json; charset=utf-8\&quot;);\n   479\t                return new Response(status, h, bytes);\n   480\t            } catch (Exception e) { throw new RuntimeException(e); }\n   481\t        }\n   482\t        Response withHeader(String k, String v){ headers.put(k, v); return this; }\n   483\t    }\n   484\t\n   485\t    static void write(HttpExchange ex, Response resp) throws IOException {\n   486\t        Headers h = ex.getResponseHeaders();\n   487\t        resp.headers.forEach(h::set);\n   488\t        long len = (resp.body == null || resp.status == 204) ? -1 : resp.body.length;\n   489\t        ex.sendResponseHeaders(resp.status, len);\n   490\t        if (resp.body != null &amp;&amp; resp.status != 204) try (var os = ex.getResponseBody()) { os.write(resp.body); }\n   491\t    }\n   492\t\n   493\t    static void addCORS(HttpExchange ex) {\n   494\t        Headers h = ex.getResponseHeaders();\n   495\t        h.add(\&quot;Access-Control-Allow-Origin\&quot;, \&quot;*\&quot;);\n   496\t        h.add(\&quot;Access-Control-Allow-Methods\&quot;, \&quot;GET,POST,PUT,DELETE,OPTIONS\&quot;);\n   497\t        h.add(\&quot;Access-Control-Allow-Headers\&quot;, \&quot;Content-Type, Authorization\&quot;);\n   498\t    }\n   499\t    static boolean handleCorsPreflight(HttpExchange ex) throws IOException {\n   500\t        if (!\&quot;OPTIONS\&quot;.equals(ex.getRequestMethod())) return false;\n   501\t        ex.sendResponseHeaders(204, -1); return true;\n   502\t    }\n   503\t    static void withLatency(Long ms) { if (ms == null || ms &lt;= 0) return; try { Thread.sleep(ms); } catch (InterruptedException ignored) {} }\n   504\t    static void maybeChaos(Double rate) { if (rate == null || rate &lt;= 0) return; if (ThreadLocalRandom.current().nextDouble() &lt; rate) throw new RuntimeException(\&quot;chaos\&quot;); }\n   505\t    static boolean isAuthorized(Ctx ctx) {\n   506\t        if (blank(ctx.cfg.authToken)) return true;\n   507\t        var h = ctx.header(\&quot;Authorization\&quot;);\n   508\t        return h != null &amp;&amp; h.equals(\&quot;Bearer \&quot; + ctx.cfg.authToken);\n   509\t    }\n   510\t\n   511\t    static ObjectMapper jsonMapper() { return new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); }\n   512\t    static ObjectMapper yamlMapper() { return new ObjectMapper(new YAMLFactory()).configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); }\n   513\t    static Map&lt;String,Object&gt; deepCopy(Map&lt;String,Object&gt; m) { return jsonMapper().convertValue(m, new TypeReference&lt;Map&lt;String,Object&gt;&gt;(){}); }\n   514\t    static boolean blank(String s){ return s==null || s.isBlank(); }\n   515\t\n   516\t    // ---------- In-memory store ----------\n   517\t    static class ResourceStore {\n   518\t        final String name; final String idField; final ConcurrentMap&lt;String, Map&lt;String,Object&gt;&gt; data = new ConcurrentHashMap&lt;&gt;();\n   519\t        ResourceStore(String name, String idField) { this.name = name; this.idField = idField; }\n   520\t        void put(String id, Map&lt;String,Object&gt; row){ data.put(id, deepCopy(row)); }\n   521\t        Map&lt;String,Object&gt; get(String id){ return data.get(id); }\n   522\t        boolean remove(String id){ return data.remove(id) != null; }\n   523\t        List&lt;Map&lt;String,Object&gt;&gt; list(int limit, int offset) {\n   524\t            return data.values().stream()\n   525\t                    .sorted(Comparator.comparing(o -&gt; String.valueOf(o.getOrDefault(idField, \&quot;\&quot;))))\n   526\t                    .skip(Math.max(0, offset))\n   527\t                    .limit(Math.max(1, limit))\n   528\t                    .map(TinyRest::deepCopy)\n   529\t                    .collect(Collectors.toList());\n   530\t        }\n   531\t    }\n   532\t\n   533\t    // ---------- Config / Features ----------\n   534\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   535\t    public static class MockConfig {\n   536\t        public Integer port;\n   537\t        public String authToken;\n   538\t        public Long artificialLatencyMs;\n   539\t        public Double chaosFailRate;\n   540\t        public FeaturesConfig features;\n   541\t        public List&lt;Resource&gt; resources;\n   542\t        public List&lt;StaticEndpoint&gt; staticEndpoints;\n   543\t    }\n   544\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   545\t    public static class Resource {\n   546\t        public String name;\n   547\t        public String idField;\n   548\t        public Boolean enableCrud;\n   549\t        public List&lt;Map&lt;String,Object&gt;&gt; seed;\n   550\t    }\n   551\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   552\t    public static class StaticEndpoint {\n   553\t        public String method;\n   554\t        public String path;\n   555\t        public Integer status;\n   556\t        public Map&lt;String,Object&gt; response;\n   557\t        public Boolean echoRequest;\n   558\t    }\n   559\t\n   560\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   561\t    public static class FeaturesConfig {\n   562\t        public Boolean templating;\n   563\t        public Boolean hotReload;\n   564\t        public String schemaValidation; // strict|lenient\n   565\t        public RecordReplay recordReplay;\n   566\t    }\n   567\t\n   568\t    static class Features {\n   569\t        final boolean templating;\n   570\t        final boolean hotReload;\n   571\t        final String schemaValidation;\n   572\t        final RecordReplay recordReplay;\n   573\t        static Features from(FeaturesConfig c) {\n   574\t            if (c == null) c = new FeaturesConfig();\n   575\t            return new Features(\n   576\t                    Boolean.TRUE.equals(c.templating),\n   577\t                    Boolean.TRUE.equals(c.hotReload),\n   578\t                    blank(c.schemaValidation) ? \&quot;lenient\&quot; : c.schemaValidation,\n   579\t                    c.recordReplay == null ? new RecordReplay() : c.recordReplay);\n   580\t        }\n   581\t        Features(boolean t, boolean hr, String sv, RecordReplay rr){ this.templating=t; this.hotReload=hr; this.schemaValidation=sv; this.recordReplay=rr; }\n   582\t    }\n   583\t\n   584\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   585\t    public static class RecordReplay {\n   586\t        public String mode;           // off|record|replay\n   587\t        public String file;           // JSONL file\n   588\t        public Match match;\n   589\t        public String replayOnMiss;   // error|fallback\n   590\t    }\n   591\t\n   592\t    @JsonIgnoreProperties(ignoreUnknown = true)\n   593\t    public static class Match {\n   594\t        public Boolean method;\n   595\t        public Boolean path;\n   596\t        public Boolean query;\n   597\t        public Boolean body;\n   598\t        public List&lt;String&gt; headers;\n   599\t    }\n   600\t\n   601\t    static class ReplayItem {\n   602\t        public Map&lt;String,Object&gt; request;\n   603\t        public Map&lt;String,Object&gt; response;\n   604\t\n   605\t        static ReplayItem from(HttpExchange ex, Response resp, RecordReplay rr) throws IOException {\n   606\t            var it = new ReplayItem();\n   607\t            it.request = captureRequest(ex).toMap();\n   608\t            it.response = Map.of(\n   609\t                    \&quot;status\&quot;, resp.status,\n   610\t                    \&quot;headers\&quot;, ex.getResponseHeaders(), // response headers as set on exchange\n   611\t                    \&quot;bodyBase64\&quot;, Base64.getEncoder().encodeToString(resp.body == null ? new byte[0] : resp.body)\n   612\t            );\n   613\t            return it;\n   614\t        }\n   615\t\n   616\t        static CapturedRequest captureRequest(HttpExchange ex) {\n   617\t            String body = \&quot;\&quot;;\n   618\t            try (var is = ex.getRequestBody()) { body = new String(is.readAllBytes(), StandardCharsets.UTF_8); }\n   619\t            catch (Exception ignored) {}\n   620\t            Map&lt;String, List&lt;String&gt;&gt; headers = new LinkedHashMap&lt;&gt;();\n   621\t            ex.getRequestHeaders().forEach(headers::put);\n   622\t            return new CapturedRequest(ex.getRequestMethod(), ex.getRequestURI().getPath(), ex.getRequestURI().getRawQuery(), headers, body);\n   623\t        }\n   624\t\n   625\t        boolean matches(CapturedRequest req, RecordReplay rr) {\n   626\t            Match m = rr.match == null ? new Match() : rr.match;\n   627\t            boolean ok = true;\n   628\t            if (Boolean.TRUE.equals(m.method)) ok &amp;= Objects.equals(val(request, \&quot;method\&quot;), req.method);\n   629\t            if (Boolean.TRUE.equals(m.path))   ok &amp;= Objects.equals(val(request, \&quot;path\&quot;), req.path);\n   630\t            if (Boolean.TRUE.equals(m.query))  ok &amp;= Objects.equals(val(request, \&quot;query\&quot;), req.query);\n   631\t            if (Boolean.TRUE.equals(m.body))   ok &amp;= Objects.equals(val(request, \&quot;body\&quot;), req.body);\n   632\t            if (m.headers != null &amp;&amp; !m.headers.isEmpty()) {\n   633\t                @SuppressWarnings(\&quot;unchecked\&quot;)\n   634\t                Map&lt;String,List&lt;String&gt;&gt; h1 = (Map&lt;String,List&lt;String&gt;&gt;) request.get(\&quot;headers\&quot;);\n   635\t                for (String name : m.headers) {\n   636\t                    String k = canonicalHeader(h1, name);\n   637\t                    String k2 = canonicalHeader(req.headers, name);\n   638\t                    ok &amp;= Objects.equals(h1.get(k), req.headers.get(k2));\n   639\t                }\n   640\t            }\n   641\t            return ok;\n   642\t        }\n   643\t        static String canonicalHeader(Map&lt;String,?&gt; map, String name) {\n   644\t            for (String k : map.keySet()) if (k.equalsIgnoreCase(name)) return k;\n   645\t            return name;\n   646\t        }\n   647\t        static Object val(Map&lt;String,Object&gt; m, String k){ return m.get(k); }\n   648\t\n   649\t        Response toResponse() {\n   650\t            int status = (int) response.get(\&quot;status\&quot;);\n   651\t            byte[] body = new byte[0];\n   652\t            String b64 = String.valueOf(response.get(\&quot;bodyBase64\&quot;));\n   653\t            if (!\&quot;null\&quot;.equals(b64)) body = Base64.getDecoder().decode(b64);\n   654\t            Map&lt;String,String&gt; headers = new LinkedHashMap&lt;&gt;();\n   655\t            headers.put(\&quot;Content-Type\&quot;, \&quot;application/json; charset=utf-8\&quot;);\n   656\t            return new Response(status, headers, body);\n   657\t        }\n   658\t\n   659\t        static class CapturedRequest {\n   660\t            final String method, path, query, body; final Map&lt;String,List&lt;String&gt;&gt; headers;\n   661\t            CapturedRequest(String method, String path, String query, Map&lt;String,List&lt;String&gt;&gt; headers, String body) {\n   662\t                this.method = method; this.path = path; this.query = query; this.headers = headers; this.body = body;\n   663\t            }\n   664\t            Map&lt;String,Object&gt; toMap() {\n   665\t                return Map.of(\&quot;method\&quot;, method, \&quot;path\&quot;, path, \&quot;query\&quot;, query, \&quot;headers\&quot;, headers, \&quot;body\&quot;, body);\n   666\t            }\n   667\t        }\n   668\t    }\n   669\t\n   670\t    // ---------- Validation ----------\n   671\t    static void validateOrDie(MockConfig c) {\n   672\t        var errors = new ArrayList&lt;String&gt;();\n   673\t        if (c.resources != null) {\n   674\t            var names = new HashSet&lt;String&gt;();\n   675\t            for (var r : c.resources) {\n   676\t                if (blank(r.name)) errors.add(\&quot;resource.name is required\&quot;);\n   677\t                if (!names.add(r.name)) errors.add(\&quot;duplicate resource.name: \&quot; + r.name);\n   678\t                if (blank(r.idField)) errors.add(\&quot;resource.idField is required for: \&quot; + r.name);\n   679\t            }\n   680\t        }\n   681\t        if (c.staticEndpoints != null) {\n   682\t            for (var s : c.staticEndpoints) {\n   683\t                if (blank(s.path)) errors.add(\&quot;staticEndpoint.path is required\&quot;);\n   684\t            }\n   685\t        }\n   686\t        if (!errors.isEmpty()) throw new IllegalArgumentException(\&quot;Invalid config: \&quot; + errors);\n   687\t    }\n   688\t    static void validateLenient(MockConfig c) {\n   689\t        try { validateOrDie(c); } catch (Exception e) { System.err.println(\&quot;[lenient] \&quot; + e.getMessage()); }\n   690\t    }\n   691\t\n   692\t    // ---------- Control handle ----------\n   693\t    public static class ServerHandle {\n   694\t        private final HttpServer server; private final Engine engine;\n   695\t        ServerHandle(HttpServer server, Engine engine){ this.server = server; this.engine = engine; }\n   696\t        public void stop(int delaySec){ server.stop(delaySec); }\n   697\t        public InetSocketAddress boundAddress(){ return (InetSocketAddress) server.getAddress(); }\n   698\t    }\n   699\t\n   700\t    // ---------- Errors ----------\n   701\t    static class BadRequest extends RuntimeException { BadRequest(String m){ super(m); } }\n   702\t    static class Unauthorized extends RuntimeException { Unauthorized(String m){ super(m); } }\n   703\t\n   704\t    private static MockConfig defaults(MockConfig in) {\n   705\t        MockConfig c = in == null ? new MockConfig() : in;\n   706\t        if (c.port == null) c.port = 8080;\n   707\t        if (c.artificialLatencyMs == null) c.artificialLatencyMs = 0L;\n   708\t        if (c.chaosFailRate == null) c.chaosFailRate = 0.0;\n   709\t        if (c.features == null) c.features = new FeaturesConfig();\n   710\t        return c;\n   711\t    }\n   712\t\n   713\t    // ===== JUnit 5 Integration (TinyRest) =====\n   714\t    // Place this file under src/main/java and add JUnit 5 as a test-scoped dependency.\n   715\t    // Tests can then: @ExtendWith(TinyRest.JUnitTinyRestExtension.class) and @UseTinyRest(...)\n   716\t    // Params can be injected with @TinyRestBaseUrl on String or URI.\n   717\t\n   718\t    // (Imports for JUnit are at top-level in your test compile; here we fully-qualify to avoid extra imports.)\n   719\t\n   720\t    public static class JUnitTinyRestExtension implements org.junit.jupiter.api.extension.BeforeAllCallback,\n   721\t            org.junit.jupiter.api.extension.AfterAllCallback,\n   722\t            org.junit.jupiter.api.extension.ParameterResolver {\n   723\t\n   724\t        private static final org.junit.jupiter.api.extension.ExtensionContext.Namespace NS =\n   725\t                org.junit.jupiter.api.extension.ExtensionContext.Namespace.create(\&quot;TinyRest\&quot;);\n   726\t        private static final String STORE_KEY = \&quot;serverHandle\&quot;;\n   727\t\n   728\t        @Override\n   729\t        public void beforeAll(org.junit.jupiter.api.extension.ExtensionContext context) throws Exception {\n   730\t            var store = context.getStore(NS);\n   731\t\n   732\t            UseTinyRest cfgAnn = findAnnotation(context, UseTinyRest.class);\n   733\t            if (cfgAnn == null) {\n   734\t                throw new IllegalStateException(\&quot;@UseTinyRest is required on the test class when using JUnitTinyRestExtension.\&quot;);\n   735\t            }\n   736\t\n   737\t            String configPath = cfgAnn.configPath().isBlank() ? \&quot;src/test/resources/tinyrest.yml\&quot; : cfgAnn.configPath();\n   738\t            TinyRest.MockConfig cfg = TinyRest.loadConfig(configPath);\n   739\t\n   740\t            if (cfgAnn.port() &gt;= 0) cfg.port = cfgAnn.port(); // 0 =&gt; auto-bind\n   741\t            if (!cfgAnn.authTokenOverride().isBlank()) cfg.authToken = cfgAnn.authTokenOverride();\n   742\t\n   743\t            if (cfg.features == null) cfg.features = new FeaturesConfig();\n   744\t            if (!cfgAnn.recordReplayMode().isBlank()) {\n   745\t                if (cfg.features.recordReplay == null) cfg.features.recordReplay = new RecordReplay();\n   746\t                cfg.features.recordReplay.mode = cfgAnn.recordReplayMode();\n   747\t                if (!cfgAnn.recordReplayFile().isBlank()) cfg.features.recordReplay.file = cfgAnn.recordReplayFile();\n   748\t            }\n   749\t\n   750\t            var handle = TinyRest.start(cfg, java.nio.file.Paths.get(configPath));\n   751\t            store.put(STORE_KEY, handle);\n   752\t\n   753\t            String baseUrl = \&quot;http://localhost:\&quot; + handle.boundAddress().getPort();\n   754\t            System.setProperty(\&quot;tinyrest.baseUrl\&quot;, baseUrl);\n   755\t            System.setProperty(\&quot;tinyrest.port\&quot;, String.valueOf(handle.boundAddress().getPort()));\n   756\t        }\n   757\t\n   758\t        @Override\n   759\t        public void afterAll(org.junit.jupiter.api.extension.ExtensionContext context) throws Exception {\n   760\t            var store = context.getStore(NS);\n   761\t            var handle = (TinyRest.ServerHandle) store.remove(STORE_KEY);\n   762\t            if (handle != null) handle.stop(0);\n   763\t        }\n   764\t\n   765\t        // --- Parameter injection ---\n   766\t        @Override\n   767\t        public boolean supportsParameter(org.junit.jupiter.api.extension.ParameterContext pc,\n   768\t                                         org.junit.jupiter.api.extension.ExtensionContext ec)\n   769\t                throws org.junit.jupiter.api.extension.ParameterResolutionException {\n   770\t            boolean wantBaseUrl = pc.isAnnotated(TinyRestBaseUrl.class) &amp;&amp;\n   771\t                    (pc.getParameter().getType().equals(String.class) || pc.getParameter().getType().equals(URI.class));\n   772\t            boolean wantHandle = pc.getParameter().getType().equals(TinyRest.ServerHandle.class);\n   773\t            return wantBaseUrl || wantHandle;\n   774\t        }\n   775\t\n   776\t        @Override\n   777\t        public Object resolveParameter(org.junit.jupiter.api.extension.ParameterContext pc,\n   778\t                                       org.junit.jupiter.api.extension.ExtensionContext ec)\n   779\t                throws org.junit.jupiter.api.extension.ParameterResolutionException {\n   780\t            var store = ec.getStore(NS);\n   781\t            var handle = (TinyRest.ServerHandle) store.get(STORE_KEY, TinyRest.ServerHandle.class);\n   782\t            if (handle == null) throw new org.junit.jupiter.api.extension.ParameterResolutionException(\&quot;TinyRest server not initialized.\&quot;);\n   783\t\n   784\t            if (pc.getParameter().getType().equals(TinyRest.ServerHandle.class)) return handle;\n   785\t            String base = \&quot;http://localhost:\&quot; + handle.boundAddress().getPort();\n   786\t            if (pc.getParameter().getType().equals(URI.class)) return URI.create(base);\n   787\t            return base; // String\n   788\t        }\n   789\t\n   790\t        private static &lt;A extends java.lang.annotation.Annotation&gt; A findAnnotation(\n   791\t                org.junit.jupiter.api.extension.ExtensionContext ctx, Class&lt;A&gt; type) {\n   792\t            var el = ctx.getElement().orElse(null);\n   793\t            if (el != null &amp;&amp; el.isAnnotationPresent(type)) return el.getAnnotation(type);\n   794\t            var cls = ctx.getRequiredTestClass();\n   795\t            return cls.getAnnotation(type);\n   796\t        }\n   797\t    }\n   798\t\n   799\t    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n   800\t    @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE)\n   801\t    public @interface UseTinyRest {\n   802\t        String configPath() default \&quot;src/test/resources/tinyrest.yml\&quot;;\n   803\t        int port() default 0;                       // 0 =&gt; random free port\n   804\t        String authTokenOverride() default \&quot;\&quot;;\n   805\t        String recordReplayMode() default \&quot;\&quot;;       // \&quot;\&quot;, \&quot;record\&quot;, \&quot;replay\&quot;\n   806\t        String recordReplayFile\&quot; default \&quot;\&quot;;\n   807\t    }\n   808\t\n   809\t    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n   810\t    @java.lang.annotation.Target(java.lang.annotation.ElementType.PARAMETER)\n   811\t    public @interface TinyRestBaseUrl {}\n   812\t}\n   813\t```\n   814\t\n   815\t        **Note:** In the `@UseTinyRest` annotation above, fix the typo if your IDE flags it (should be `recordReplayFile()` — I kept it readable here, but your compiler will enforce it). Also make sure your Maven `pom.xml` includes Jackson YAML as a runtime dep and JUnit 5 as a **test** scope dep so `TinyRest.java` compiles in `main` while tests compile against JUnit.\n   816\t\n   817\tIf you want, I can also drop in a minimal `tinyrest.yml` starter and a sample JUnit test file wired to this class.\n   818\t\nTotal lines in file: 818\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;5e18c232-3846-4c48-b02c-b73ea56b53b2;toolu_016zW7VL1HcuKyBLmzzn1gQK&quot;:{&quot;requestId&quot;:&quot;5e18c232-3846-4c48-b02c-b73ea56b53b2&quot;,&quot;toolUseId&quot;:&quot;toolu_016zW7VL1HcuKyBLmzzn1gQK&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test, excluding hidden items:\nsrc/test/java\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;5c93fce0-3d51-4b79-9684-7020a1f82048;toolu_014wrnox7aKkUqxaAQe1RW6V&quot;:{&quot;requestId&quot;:&quot;5c93fce0-3d51-4b79-9684-7020a1f82048&quot;,&quot;toolUseId&quot;:&quot;toolu_014wrnox7aKkUqxaAQe1RW6V&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test/java, excluding hidden items:\n(empty directory)\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;fed7f776-1d6b-4b8f-8a8d-5d49dd85b787;toolu_011Jbdh6ZkogY5wnT6mZC3PF&quot;:{&quot;requestId&quot;:&quot;fed7f776-1d6b-4b8f-8a8d-5d49dd85b787&quot;,&quot;toolUseId&quot;:&quot;toolu_011Jbdh6ZkogY5wnT6mZC3PF&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the files and directories up to 2 levels deep in src/test, excluding hidden items:\nsrc/test/java\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}}},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:true,&quot;extraData&quot;:{&quot;isAgentConversation&quot;:true,&quot;hasAgentOnboarded&quot;:true,&quot;hasDirtyEdits&quot;:false},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;96d3c5c2-27f7-40f3-8f46-9af1b4c6560c&quot;}},&quot;agentExecutionMode&quot;:&quot;manual&quot;,&quot;isPanelCollapsed&quot;:true,&quot;displayedAnnouncements&quot;:[]}" />
      </map>
    </option>
  </component>
</project>